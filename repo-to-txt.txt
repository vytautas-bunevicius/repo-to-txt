=== .git/HEAD ===
ref: refs/heads/main


=== .git/config ===
[core]
	bare = false
[remote "origin"]
	url = git@github.com:vytautas-bunevicius/repo-to-txt.git
	fetch = +refs/heads/*:refs/remotes/origin/*
[branch "main"]
	remote = origin
	merge = refs/heads/main


=== .git/refs/heads/main ===
47d1429195636f53e787c503e108effd97be721b


=== .git/refs/remotes/origin/main ===
47d1429195636f53e787c503e108effd97be721b


=== LICENSE ===
This is free and unencumbered software released into the public domain.

Anyone is free to copy, modify, publish, use, compile, sell, or
distribute this software, either in source code form or as a compiled
binary, for any purpose, commercial or non-commercial, and by any
means.

In jurisdictions that recognize copyright laws, the author or authors
of this software dedicate any and all copyright interest in the
software to the public domain. We make this dedication for the benefit
of the public at large and to the detriment of our heirs and
successors. We intend this dedication to be an overt act of
relinquishment in perpetuity of all present and future rights to this
software under copyright law.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

For more information, please refer to <https://unlicense.org>


=== README.md ===
# repo-to-txt

**repo-to-txt** is a versatile Command-Line Interface (CLI) tool written in Go that consolidates all contents of a GitHub repository into a single `.txt` file. The output file is automatically named after the repository and can be saved to a specified directory, ensuring organized and easily identifiable documentation of repository contents.

## Table of Contents

- [Features](#features)
- [Prerequisites](#prerequisites)
- [Installation](#installation)
  - [Building from Source](#building-from-source)
  - [Making repo-to-txt Globally Accessible](#making-repo-to-txt-globally-accessible)
- [Usage](#usage)
  - [Interactive Mode](#interactive-mode)
  - [Command-Line Flags](#command-line-flags)
- [Excluding Specific Folders](#excluding-specific-folders)
  - [Interactive Exclusions](#interactive-exclusions)
  - [Command-Line Exclusions](#command-line-exclusions)
- [Including Specific File Extensions](#including-specific-file-extensions)
  - [Command-Line Inclusion](#command-line-inclusion)
- [Including Specific Files](#including-specific-files)
  - [Command-Line File Inclusion](#command-line-file-inclusion)
- [Clipboard Copying](#clipboard-copying)
  - [Installing Clipboard Utilities](#installing-clipboard-utilities)
  - [Using Clipboard Copying](#using-clipboard-copying)
- [Authentication Methods](#authentication-methods)
  - [No Authentication](#no-authentication)
  - [HTTPS Authentication with PAT](#https-authentication-with-pat)
  - [SSH Authentication](#ssh-authentication)
- [Examples](#examples)
- [Error Handling](#error-handling)
- [Contributing](#contributing)
- [License](#license)

## Features

- **Automatic Output Naming**: Generates a `.txt` file named after the repository.
- **Customizable Output Directory**: Allows specifying the directory where the output file should be saved.
- **Single Consolidated File**: Merges all repository contents into one `.txt` file with clear file path separators.
- **Support for Public and Private Repositories**: Clone public repositories without authentication or private repositories using HTTPS or SSH.
- **Excluding Specific Folders**: Specify folders to exclude from the output using command-line flags or interactive prompts.
- **Including Specific File Extensions**: Optionally include only specified file extensions to focus on relevant files.
- **Including Specific Files**: Select exact file names to include in the consolidated `.txt` output, with their paths clearly indicated.
- **Flexible Input Methods**: Supports both interactive prompts and command-line flags for providing inputs.
- **Cross-Platform Compatibility**: Works seamlessly on Windows, macOS, and Linux.
- **Security Enhancements**:
  - Handles sensitive information like Personal Access Tokens (PATs) securely.
  - Supports SSH keys with passphrases, enhancing SSH authentication security.
- **Clipboard Copying**: Optionally copy the generated `.txt` file content directly to the clipboard for quick access.
- **Improved Error Handling and Logging**: Provides more descriptive error messages to aid in troubleshooting.

## Prerequisites

- **Go**: Ensure that [Go](https://golang.org/dl/) is installed on your system. The tool is compatible with Go version 1.16 and above.
- **Git**: Required for cloning repositories. Ensure that [Git](https://git-scm.com/downloads) is installed and available in your system's PATH.
- **Clipboard Utilities** (Optional): To enable the clipboard copying feature, install one of the supported clipboard utilities as detailed below.

## Installation

### Building from Source

1. **Clone the Repository**

   ```sh
   git clone https://github.com/vytautas-bunevicius/repo-to-txt.git
   cd repo-to-txt
   ```

2. **Build the Executable**

   ```sh
   go build -o repo-to-txt ./cmd/repo-to-txt
   ```

   This command compiles the Go program and generates an executable named `repo-to-txt` in the current directory.

### Making repo-to-txt Globally Accessible

To run `repo-to-txt` from any directory, you need to add the directory containing the executable to your system's `PATH` environment variable.

**Unix-like systems (Linux, macOS):**

1. **Move the executable to a directory in your PATH:**
   Common locations include `/usr/local/bin` or `/usr/bin`.
   ```sh
   sudo mv repo-to-txt /usr/local/bin/
   ```

2. **Alternatively, add the executable's current directory to your PATH:**
   Open your shell's configuration file (e.g., `~/.bashrc` or `~/.zshrc`) and add the following line, replacing `/path/to` with the actual path to the executable:
   ```bash
   export PATH="$PATH:/path/to"
   ```
   Then, reload the shell configuration:
   ```bash
   source ~/.bashrc # or source ~/.zshrc
   ```

**Windows:**

1. **Move the executable to a directory in your PATH:**
   You can find the directories in your PATH by searching for "environment variables" in the Start menu and selecting "Edit the system environment variables".

2. **Alternatively, add the executable's current directory to your PATH:**
   - Search for "Environment Variables" in the Start menu.
   - Click on "Environment Variables" in the System Properties window.
   - Under "User variables" or "System variables," find and select the `Path` variable, then click "Edit."
   - Click "New" and add the path to the directory containing `repo-to-txt.exe`.
   - Click "OK" on all open dialog boxes to apply the changes.

## Usage

`repo-to-txt` can be used in two modes:

1. **Interactive Mode**: Prompts the user step-by-step for necessary inputs.
2. **Command-Line Flags**: Allows users to provide all inputs upfront for automation and scripting.

### Interactive Mode

Simply run the executable without any flags, and the tool will guide you through the process.

```sh
repo-to-txt
```

**Sample Interaction:**

```
Enter the GitHub repository URL (HTTPS or SSH): https://github.com/vytautas-bunevicius/repo-to-txt.git
? Select authentication method:
❯ No Authentication
  HTTPS with PAT
  SSH
Enter the output directory (default "/home/user/Downloads"): /path/to/output
Enter folders to exclude (comma-separated, leave empty to include all): vendor, tests
Enter file extensions to include (comma-separated, leave empty to include all): .go,.md
Enter exact file names to copy (comma-separated, leave empty to copy all files): prompt.go, main.go
Do you want to copy the output to the clipboard?
❯ Yes
  No
2024/09/15 10:35:09 Welcome to repo-to-txt!
Cloning repository: https://github.com/vytautas-bunevicius/repo-to-txt.git
Enumerating objects: 132, done.
Total 132 (delta 0), reused 0 (delta 0), pack-reused 132 (from 1)
2024/09/15 10:35:17 Added prompt.go to /path/to/output/repo-to-txt.txt
2024/09/15 10:35:17 Added main.go to /path/to/output/repo-to-txt.txt
2024/09/15 10:35:17 Specified files' contents written to /path/to/output/repo-to-txt.txt
2024/09/15 10:35:17 Specified files' contents have been copied to the clipboard.
```

### Command-Line Flags

Provide necessary inputs via flags to run the tool non-interactively.

```sh
repo-to-txt -repo=<repository_url> -auth=<authentication_method> [additional_flags]
```

**Available Flags:**

- `-repo`: **(Required)** GitHub repository URL (HTTPS or SSH).
- `-auth`: Authentication method. Options: `none`, `https`, `ssh`.
- `-username`: GitHub username (required for HTTPS).
- `-pat`: GitHub Personal Access Token (required for HTTPS).
- `-ssh-key`: Path to SSH private key (required for SSH).
- `-ssh-passphrase`: Passphrase for SSH private key (if protected).
- `-output-dir`: The directory where the output file should be saved. Defaults to the user's Downloads directory.
- `-exclude`: Comma-separated list of folders to exclude from the output.
- `-include-ext`: Comma-separated list of file extensions to include (e.g., `.go,.md`). If not set, defaults to excluding certain non-code files like `.ipynb`.
- `-files`: Comma-separated list of exact file names to copy from the repository.
- `-copy-clipboard`: Copy the output to the clipboard after creation. Options: `true`, `false`.
- `-version`: Print the version number and exit.

**Note**: The output file is automatically named after the repository (e.g., `repository-name.txt`).

**Example Command:**

```sh
repo-to-txt -repo=https://github.com/vytautas-bunevicius/repo-to-txt.git -auth=none -output-dir=/path/to/output -exclude="vendor,tests" -include-ext=".go,.md" -files="prompt.go,main.go" -copy-clipboard=true
```

## Excluding Specific Folders

You can specify folders that you want to exclude from the `.txt` output. This can be done either interactively or via command-line flags.

### Interactive Exclusions

When running the tool in interactive mode, after selecting the authentication method, you will be prompted to enter folders to exclude.

**Sample Interaction:**

```
Enter folders to exclude (comma-separated, leave empty to include all): vendor, tests
```

### Command-Line Exclusions

Use the `-exclude` flag followed by a comma-separated list of folder names to exclude from the output.

**Usage Example:**

```sh
repo-to-txt -repo=https://github.com/vytautas-bunevicius/repo-to-txt.git -auth=none -output-dir=/path/to/output -exclude="vendor,tests"
```

## Including Specific File Extensions

By default, the tool excludes non-code files like `.ipynb`. You can specify which file extensions to include using the `-include-ext` flag.

### Command-Line Inclusion

Use the `-include-ext` flag followed by a comma-separated list of file extensions to include only those files in the output.

**Usage Example:**

```sh
repo-to-txt -repo=https://github.com/vytautas-bunevicius/repo-to-txt.git -auth=none -output-dir=/path/to/output -include-ext=".go,.md"
```

**Note**: If `-include-ext` is not set, the tool defaults to excluding non-code files such as `.ipynb`.

## Including Specific Files

In addition to excluding folders and including specific file extensions, you can select exact file names to include in the consolidated `.txt` output. This allows you to focus on particular files within the repository.

### Command-Line File Inclusion

Use the `-files` flag followed by a comma-separated list of exact file names you wish to include in the output.

**Usage Example:**

```sh
repo-to-txt -repo=https://github.com/vytautas-bunevicius/repo-to-txt.git -auth=none -output-dir=/path/to/output -files="prompt.go,main.go"
```

**Note**:
- If multiple files with the same name exist in different directories, the tool will prompt you to select which one to include.
- The output `.txt` file will include the path of each specified file as a separator before its contents.

**Sample Output (`repo-to-txt.txt`):**

```
=== prompt.go ===
<Contents of prompt.go>

=== main.go ===
<Contents of main.go>
```

## Clipboard Copying

`repo-to-txt` offers an optional feature to copy the generated `.txt` file content directly to the clipboard for quick access.

### Installing Clipboard Utilities

To enable clipboard copying, you need to have one of the supported clipboard utilities installed on your system. The tool relies on external utilities to interact with the system clipboard.

#### **Supported Clipboard Utilities:**

- **For X11 (Most Linux Distributions):**
  - `xclip`
  - `xsel`

- **For Wayland (Modern Linux Display Server):**
  - `wl-clipboard`

- **For Termux (Android Terminal Emulator):**
  - `Termux:API` add-on

#### **Installing `xclip` (Recommended for X11 Environments):**

**Ubuntu/Debian:**

```bash
sudo apt update
sudo apt install xclip
```

**Fedora:**

```bash
sudo dnf install xclip
```

**Arch Linux:**

```bash
sudo pacman -S xclip
```

#### **Installing `xsel`:**

**Ubuntu/Debian:**

```bash
sudo apt update
sudo apt install xsel
```

**Fedora:**

```bash
sudo dnf install xsel
```

**Arch Linux:**

```bash
sudo pacman -S xsel
```

#### **Installing `wl-clipboard` (For Wayland Environments):**

**Ubuntu/Debian:**

```bash
sudo apt update
sudo apt install wl-clipboard
```

**Fedora:**

```bash
sudo dnf install wl-clipboard
```

**Arch Linux:**

```bash
sudo pacman -S wl-clipboard
```

#### **Installing Termux:API (For Termux on Android):**

1. **Install Termux:API Add-on:**
   - Download and install the [Termux:API](https://play.google.com/store/apps/details?id=com.termux.api) app from the Google Play Store or F-Droid.

2. **Install `termux-api` Package:**

   ```bash
   pkg install termux-api
   ```

#### **Verify Installation**

After installing a clipboard utility, verify that it's accessible:

- **For `xclip`:**

  ```bash
  xclip -version
  ```

- **For `xsel`:**

  ```bash
  xsel --version
  ```

- **For `wl-clipboard`:**

  ```bash
  wl-copy --version
  ```

- **For Termux:API:**

  ```bash
  termux-clipboard-get --help
  ```

If the installation was successful, these commands should display version information or help text.

### Using Clipboard Copying

When running `repo-to-txt`, use the `-copy-clipboard` flag to enable clipboard copying.

**Command-Line Example:**

```sh
repo-to-txt -repo=https://github.com/vytautas-bunevicius/repo-to-txt.git -auth=none -output-dir=/path/to/output -copy-clipboard=true
```

**Interactive Mode:**

During interactive prompts, you will be asked whether you want to copy the output to the clipboard. Select **"Yes"** to enable this feature.

**Sample Interaction:**

```
Do you want to copy the output to the clipboard?
❯ Yes
  No
```

**Error Handling:**

If no supported clipboard utility is found, the tool will log an error message but continue execution:

```
2024/09/15 10:35:17 Repository contents written to /path/to/output/repo-to-txt.txt
2024/09/15 10:35:17 Error: failed to copy content to clipboard: No clipboard utilities available. Please install xsel, xclip, wl-clipboard or Termux:API add-on for termux-clipboard-get/set.
```

**Resolution:**

- Install one of the supported clipboard utilities as detailed in the [Clipboard Copying](#clipboard-copying) section.
- Re-run the tool to enable clipboard copying.

**Benefits of Clipboard Copying:**

- **Quick Access:** Easily paste the consolidated repository contents into documents, emails, or other applications without manually opening the `.txt` file.
- **Automation:** Facilitates workflows where repository content needs to be shared or processed further immediately after generation.

## Authentication Methods

`repo-to-txt` supports multiple authentication methods to accommodate both public and private repositories.

### No Authentication

Use this method to clone **public** repositories without providing any authentication details.

**Usage Example:**

```sh
repo-to-txt -repo=https://github.com/vytautas-bunevicius/repo-to-txt.git -auth=none -output-dir=/path/to/output
```

### HTTPS Authentication with PAT

Use this method to clone **private** repositories using your GitHub username and Personal Access Token (PAT).

**Usage Example:**

```sh
repo-to-txt -repo=https://github.com/your-username/private-repo.git -auth=https -username=your_username -pat=your_PAT -output-dir=/path/to/output
```

**Security Note:** Be cautious when using command-line flags to provide sensitive information like PATs, as they can be exposed in process listings. Consider using interactive prompts for improved security.

### SSH Authentication

Use this method to clone **private** repositories using SSH keys.

**Usage Example:**

```sh
repo-to-txt -repo=git@github.com:your-username/private-repo.git -auth=ssh -ssh-key=/path/to/id_rsa -ssh-passphrase="your_passphrase" -output-dir=/path/to/output -exclude="vendor,tests"
```

**Prerequisites:**

- Ensure that your SSH key is added to your GitHub account.
- The default SSH key path is `~/.ssh/id_rsa`. If your key is located elsewhere, specify the path using the `-ssh-key` flag.
- If your SSH key is protected with a passphrase, provide it using the `-ssh-passphrase` flag. If your key does not have a passphrase, you can omit this flag.

## Examples

### 1. Cloning a Public Repository Without Authentication and Excluding Folders to a Specific Directory

```sh
repo-to-txt -repo=https://github.com/vytautas-bunevicius/repo-to-txt.git -auth=none -output-dir=/path/to/output -exclude="vendor,tests"
```

**Output:**

```
2024/09/15 10:35:09 Welcome to repo-to-txt!
Cloning repository: https://github.com/vytautas-bunevicius/repo-to-txt.git
Enumerating objects: 132, done.
Total 132 (delta 0), reused 0 (delta 0), pack-reused 132 (from 1)
2024/09/15 10:35:17 Skipping file .git/index: binary file
2024/09/15 10:35:17 Skipping file .git/objects/pack/pack-df8004320515f54f375aa24042fb596aa7f3a2b3.idx: binary file
2024/09/15 10:35:17 Skipping file .git/objects/pack/pack-df8004320515f54f375aa24042fb596aa7f3a2b3.pack: binary file
2024/09/15 10:35:17 Skipping file repo-to-txt: binary file
2024/09/15 10:35:17 Repository contents written to /path/to/output/repo-to-txt.txt
2024/09/15 10:35:17 Repository contents have been copied to the clipboard.
```

### 2. Cloning a Private Repository Using HTTPS Authentication and Excluding Folders to a Specific Directory

```sh
repo-to-txt -repo=https://github.com/your-username/private-repo.git -auth=https -username=your_username -pat=your_PAT -output-dir=/path/to/output -exclude="vendor,tests"
```

**Output:**

```
2024/09/15 10:35:09 Welcome to repo-to-txt!
Cloning repository: https://github.com/your-username/private-repo.git
Enumerating objects: 132, done.
Total 132 (delta 0), reused 0 (delta 0), pack-reused 132 (from 1)
2024/09/15 10:35:17 Skipping file .git/index: binary file
2024/09/15 10:35:17 Skipping file .git/objects/pack/pack-df8004320515f54f375aa24042fb596aa7f3a2b3.idx: binary file
2024/09/15 10:35:17 Skipping file .git/objects/pack/pack-df8004320515f54f375aa24042fb596aa7f3a2b3.pack: binary file
2024/09/15 10:35:17 Skipping file repo-to-txt: binary file
2024/09/15 10:35:17 Repository contents written to /path/to/output/private-repo.txt
2024/09/15 10:35:17 Repository contents have been copied to the clipboard.
```

### 3. Cloning a Private Repository Using SSH Authentication Without Excluding Any Folders to a Specific Directory

```sh
repo-to-txt -repo=git@github.com:your-username/private-repo.git -auth=ssh -ssh-key=/path/to/id_rsa -output-dir=/path/to/output
```

**Output:**

```
2024/09/15 10:35:09 Welcome to repo-to-txt!
Cloning repository: git@github.com:your-username/private-repo.git
Enumerating objects: 132, done.
Total 132 (delta 0), reused 0 (delta 0), pack-reused 132 (from 1)
2024/09/15 10:35:17 Skipping file .git/index: binary file
2024/09/15 10:35:17 Skipping file .git/objects/pack/pack-df8004320515f54f375aa24042fb596aa7f3a2b3.idx: binary file
2024/09/15 10:35:17 Skipping file .git/objects/pack/pack-df8004320515f54f375aa24042fb596aa7f3a2b3.pack: binary file
2024/09/15 10:35:17 Skipping file repo-to-txt: binary file
2024/09/15 10:35:17 Repository contents written to /path/to/output/private-repo.txt
2024/09/15 10:35:17 Repository contents have been copied to the clipboard.
```

### 4. Using Interactive Mode with Exclusions and Specifying Output Directory

Run the tool without any flags and follow the interactive prompts.

```sh
repo-to-txt
```

**Sample Interaction:**

```
Enter the GitHub repository URL (HTTPS or SSH): https://github.com/vytautas-bunevicius/repo-to-txt.git
? Select authentication method:
❯ No Authentication
  HTTPS with PAT
  SSH
Enter the output directory (default "/home/user/Downloads"): /path/to/output
Enter folders to exclude (comma-separated, leave empty to include all): vendor, tests
Enter file extensions to include (comma-separated, leave empty to include all): .go,.md
Enter exact file names to copy (comma-separated, leave empty to copy all files): prompt.go, main.go
Do you want to copy the output to the clipboard?
❯ Yes
  No
2024/09/15 10:35:09 Welcome to repo-to-txt!
Cloning repository: https://github.com/vytautas-bunevicius/repo-to-txt.git
Enumerating objects: 132, done.
Total 132 (delta 0), reused 0 (delta 0), pack-reused 132 (from 1)
2024/09/15 10:35:17 Added prompt.go to /path/to/output/repo-to-txt.txt
2024/09/15 10:35:17 Added main.go to /path/to/output/repo-to-txt.txt
2024/09/15 10:35:17 Specified files' contents written to /path/to/output/repo-to-txt.txt
2024/09/15 10:35:17 Specified files' contents have been copied to the clipboard.
```

### 5. Including Specific File Extensions and Specifying Output Directory

Clone a repository and include only `.go` and `.md` files in the output, saving it to a specific directory.

```sh
repo-to-txt -repo=https://github.com/vytautas-bunevicius/repo-to-txt.git -auth=none -output-dir=/path/to/output -include-ext=".go,.md"
```

**Output:**

```
2024/09/15 10:35:09 Welcome to repo-to-txt!
Cloning repository: https://github.com/vytautas-bunevicius/repo-to-txt.git
Enumerating objects: 132, done.
Total 132 (delta 0), reused 0 (delta 0), pack-reused 132 (from 1)
2024/09/15 10:35:17 Skipping file .git/index: binary file
2024/09/15 10:35:17 Skipping file .git/objects/pack/pack-df8004320515f54f375aa24042fb596aa7f3a2b3.idx: binary file
2024/09/15 10:35:17 Skipping file .git/objects/pack/pack-df8004320515f54f375aa24042fb596aa7f3a2b3.pack: binary file
2024/09/15 10:35:17 Skipping file repo-to-txt: binary file
2024/09/15 10:35:17 Repository contents written to /path/to/output/repo-to-txt.txt
2024/09/15 10:35:17 Repository contents have been copied to the clipboard.
```

### 6. Cloning a Repository with an SSH Key Passphrase and Specifying Output Directory

If your SSH key is protected with a passphrase, provide it using the `-ssh-passphrase` flag and specify the output directory.

```sh
repo-to-txt -repo=git@github.com:your-username/private-repo.git -auth=ssh -ssh-key=/path/to/id_rsa -ssh-passphrase="your_passphrase" -output-dir=/path/to/output
```

**Output:**

```
2024/09/15 10:35:09 Welcome to repo-to-txt!
Cloning repository: git@github.com:your-username/private-repo.git
Enumerating objects: 132, done.
Total 132 (delta 0), reused 0 (delta 0), pack-reused 132 (from 1)
2024/09/15 10:35:17 Skipping file .git/index: binary file
2024/09/15 10:35:17 Skipping file .git/objects/pack/pack-df8004320515f54f375aa24042fb596aa7f3a2b3.idx: binary file
2024/09/15 10:35:17 Skipping file .git/objects/pack/pack-df8004320515f54f375aa24042fb596aa7f3a2b3.pack: binary file
2024/09/15 10:35:17 Skipping file repo-to-txt: binary file
2024/09/15 10:35:17 Repository contents written to /path/to/output/private-repo.txt
2024/09/15 10:35:17 Repository contents have been copied to the clipboard.
```

## Error Handling

The tool provides descriptive error messages to help you troubleshoot issues. Common errors include:

- **Invalid Repository URL**: Ensure that the repository URL is correct and accessible.
- **Authentication Failures**: Verify your authentication credentials or SSH key.
- **Network Issues**: Check your internet connection and firewall settings.
- **Permission Issues**: Ensure you have the necessary permissions to clone the repository and write to the output directory.
- **SSH Passphrase Errors**: If using an SSH key with a passphrase, ensure that the passphrase is correct.
- **Clipboard Utility Not Found**: If clipboard copying is enabled but no supported clipboard utility is installed, you'll receive an error prompting you to install one.

**Example Error Message:**

```
2024/09/15 10:35:17 Error: failed to copy content to clipboard: No clipboard utilities available. Please install xsel, xclip, wl-clipboard or Termux:API add-on for termux-clipboard-get/set.
```

**Resolution:**

- **For Clipboard Utility Errors:**
  - Install one of the supported clipboard utilities as detailed in the [Clipboard Copying](#clipboard-copying) section.
  - Re-run the tool to enable clipboard copying.

- **For Authentication Errors:**
  - Double-check your GitHub credentials or SSH key setup.
  - Ensure that your PAT has the necessary scopes for repository access.
  - Verify that your SSH key is correctly added to your GitHub account.

- **For Repository Cloning Errors:**
  - Ensure that the repository URL is correct.
  - Verify that you have access permissions for private repositories.
  - Check your network connection and proxy settings if applicable.

=== cmd/repo-to-txt/main.go ===
// Package main serves as the entry point for the repo-to-txt CLI tool.
// It orchestrates the configuration parsing, user prompting, repository cloning/pulling,
// and the generation of a text file containing the repository's contents.
package main

import (
	"bufio" // Added bufio package
	"context"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"

	"github.com/atotto/clipboard"
	"github.com/vytautas-bunevicius/repo-to-txt/pkg/auth"
	"github.com/vytautas-bunevicius/repo-to-txt/pkg/clone"
	"github.com/vytautas-bunevicius/repo-to-txt/pkg/config"
	"github.com/vytautas-bunevicius/repo-to-txt/pkg/output"
	"github.com/vytautas-bunevicius/repo-to-txt/pkg/prompt"
)

// main is the entry point of the repo-to-txt application.
// It initializes the context and invokes the run function.
// Any errors encountered during execution are logged and cause the program to exit.
func main() {
	ctx := context.Background()
	if err := run(ctx); err != nil {
		log.Fatalf("Error: %v", err)
	}
}

// run orchestrates the main workflow of the repo-to-txt tool.
// It performs the following steps:
//  1. Initializes a new configuration instance.
//  2. Parses command-line flags into the configuration.
//  3. Prompts the user for any missing configuration inputs.
//  4. Extracts the repository name from the provided URL.
//  5. Determines the output file path based on the configuration.
//  6. Creates a temporary directory for cloning the repository.
//  7. Sets up the authentication method.
//  8. Clones the repository or pulls the latest changes if it already exists locally.
//  9. Writes the repository contents or copies specified files to the output directory.
//
// 10. Optionally copies the contents to clipboard if requested.
//
// Parameters:
//   - ctx: The context for managing cancellation and deadlines.
//
// Returns:
//   - error: An error if any step in the workflow fails.
func run(ctx context.Context) error {
	// Initialize a new configuration instance.
	cfg := config.NewConfig()

	// Parse command-line flags into the configuration.
	if err := cfg.ParseFlags(); err != nil {
		return fmt.Errorf("error parsing flags: %w", err)
	}

	// Prompt the user for any missing configuration inputs.
	if err := prompt.PromptForMissingInputs(cfg); err != nil {
		return fmt.Errorf("error prompting for inputs: %w", err)
	}

	log.Println("Welcome to repo-to-txt!")

	// Extract the repository name from the provided URL.
	repoName, err := clone.ExtractRepoName(cfg.RepoURL)
	if err != nil {
		return fmt.Errorf("error extracting repository name: %w", err)
	}

	// Determine the output file path based on the configuration.
	outputFile := filepath.Join(cfg.OutputDir, fmt.Sprintf("%s%s", repoName, config.DefaultOutputExt))

	// Create a temporary directory for cloning the repository.
	tempDir, err := os.MkdirTemp("", config.DefaultCloneDir)
	if err != nil {
		return fmt.Errorf("unable to create temporary directory: %w", err)
	}
	defer os.RemoveAll(tempDir) // Ensure the temporary directory is removed after execution.

	// Set up the authentication method based on the configuration.
	authMethod, err := auth.SetupAuth(cfg)
	if err != nil {
		return fmt.Errorf("error setting up authentication: %w", err)
	}

	// Clone the repository or pull the latest changes if it already exists locally.
	if err := clone.CloneOrPullRepo(ctx, cfg.RepoURL, tempDir, authMethod); err != nil {
		return fmt.Errorf("error cloning/pulling repository: %w", err)
	}

	if len(cfg.FileNames) > 0 {
		// Handle writing specified files' contents to outputFile
		fileMatches, err := output.FindFiles(tempDir, cfg.FileNames)
		if err != nil {
			return fmt.Errorf("error searching for specified files: %w", err)
		}

		// Open outputFile for writing (truncate if exists)
		outFile, err := os.Create(outputFile)
		if err != nil {
			return fmt.Errorf("unable to create output file: %w", err)
		}
		defer outFile.Close()

		writer := bufio.NewWriter(outFile)
		defer writer.Flush()

		// Iterate over each specified file name
		for _, fileName := range cfg.FileNames {
			matches, exists := fileMatches[fileName]
			if !exists || len(matches) == 0 {
				log.Printf("No matches found for file name: %s", fileName)
				continue
			}

			var selectedPath string
			if len(matches) == 1 {
				selectedPath = matches[0]
				log.Printf("Found one match for %s: %s", fileName, selectedPath)
			} else {
				// Prompt user to select which file to include
				selectedPath, err = prompt.SelectFile(fileName, matches)
				if err != nil {
					return fmt.Errorf("error selecting file for %s: %w", fileName, err)
				}
			}

			// Read file content
			content, err := ioutil.ReadFile(selectedPath)
			if err != nil {
				log.Printf("Failed to read file %s: %v", selectedPath, err)
				continue
			}

			// Compute relative path
			relPath, err := filepath.Rel(tempDir, selectedPath)
			if err != nil {
				log.Printf("Failed to compute relative path for %s: %v", selectedPath, err)
				relPath = filepath.Base(selectedPath) // fallback to base name
			}

			// Write content to outputFile with separator
			separator := fmt.Sprintf("=== %s ===\n", relPath) // include relative path
			if _, err := writer.WriteString(separator); err != nil {
				log.Printf("Failed to write separator to output file: %v", err)
				continue
			}
			if _, err := writer.Write(content); err != nil {
				log.Printf("Failed to write content to output file: %v", err)
				continue
			}
			if _, err := writer.WriteString("\n\n"); err != nil {
				log.Printf("Failed to write newline to output file: %v", err)
				continue
			}

			log.Printf("Added %s to %s", selectedPath, outputFile)
		}

		// After writing all specified files
		log.Printf("Specified files' contents written to %s", outputFile)

		// Handle clipboard copy if requested
		if cfg.CopyToClipboard {
			content, err := ioutil.ReadFile(outputFile)
			if err != nil {
				return fmt.Errorf("error reading output file for clipboard: %w", err)
			}
			if err := clipboard.WriteAll(string(content)); err != nil {
				return fmt.Errorf("error copying to clipboard: %w", err)
			}
			log.Println("Specified files' contents have been copied to the clipboard.")
		} else {
			log.Println("Specified files' contents were not copied to the clipboard.")
		}
	} else {
		// Write the repository contents to the specified output file.
		if err := output.WriteRepoContentsToFile(tempDir, outputFile, cfg); err != nil {
			return fmt.Errorf("error writing repository contents to file: %w", err)
		}
		log.Printf("Repository contents written to %s", outputFile)

		// Handle clipboard copy if requested
		if cfg.CopyToClipboard {
			content, err := ioutil.ReadFile(outputFile)
			if err != nil {
				return fmt.Errorf("error reading output file for clipboard: %w", err)
			}
			if err := clipboard.WriteAll(string(content)); err != nil {
				return fmt.Errorf("error copying to clipboard: %w", err)
			}
			log.Println("Repository contents have been copied to the clipboard.")
		} else {
			log.Println("Repository contents were not copied to the clipboard.")
		}
	}

	return nil
}


=== cmd/repo-to-txt/main_test.go ===
// Package main_test contains integration tests for the repo-to-txt CLI tool.
// These tests verify the end-to-end functionality of the tool, including building the binary,
// cloning a repository, generating the output text file, and optionally copying to the clipboard.
//
// Note: Integration tests are skipped by default and can be enabled by setting the
// RUN_INTEGRATION_TESTS environment variable to "true". Clipboard tests require
// the RUN_CLIPBOARD_TESTS environment variable to be set to "true" and may fail
// in headless or restricted environments.
package main

import (
	"bytes"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"testing"

	"github.com/atotto/clipboard"
)

// TestMainIntegration performs an end-to-end integration test of the repo-to-txt CLI tool.
// It builds the binary, clones a specified repository without authentication, generates the output
// text file, and optionally verifies clipboard copying.
//
// Preconditions:
//   - The RUN_INTEGRATION_TESTS environment variable must be set to "true" to run this test.
//   - Network access is required to clone the specified GitHub repository.
//   - Clipboard access is required to verify clipboard copying if RUN_CLIPBOARD_TESTS is set to "true".
//
// Steps:
//  1. Skip the test if running in short mode or if RUN_INTEGRATION_TESTS is not set to "true".
//  2. Build the repo-to-txt binary.
//  3. Create a temporary output directory.
//  4. Execute the binary with specified command-line arguments, including the clipboard flag.
//  5. Verify that the output file is created and contains content.
//  6. Optionally, verify that the clipboard contains the expected content.
//
// Parameters:
//   - t: The testing framework's testing object.
func TestMainIntegration(t *testing.T) {
	// Skip the test in short mode to allow faster test runs.
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	// Check for the RUN_INTEGRATION_TESTS environment variable to determine if integration tests should run.
	if os.Getenv("RUN_INTEGRATION_TESTS") != "true" {
		t.Skip("Skipping integration test; set RUN_INTEGRATION_TESTS=true to run")
	}

	// Step 1: Build the binary.
	exePath := filepath.Join(os.TempDir(), "repo-to-txt-test")
	buildCmd := exec.Command("go", "build", "-o", exePath, "./")
	buildOutput, err := buildCmd.CombinedOutput()
	if err != nil {
		t.Fatalf("Failed to build binary: %v\nOutput: %s", err, string(buildOutput))
	}
	defer os.Remove(exePath) // Clean up the binary after the test.

	// Step 2: Create a temporary output directory.
	outputDir, err := ioutil.TempDir("", "repo-to-txt-output")
	if err != nil {
		t.Fatalf("Failed to create temp output directory: %v", err)
	}
	defer os.RemoveAll(outputDir) // Clean up the output directory after the test.

	// Step 3: Prepare command-line arguments.
	repoURL := "https://github.com/vytautas-bunevicius/repo-to-txt.git"
	args := []string{
		"-repo=" + repoURL,
		"-auth=none",
		"-output-dir=" + outputDir,
		"-copy-clipboard=true", // Enable clipboard copying
	}

	// Step 4: Run the binary.
	runCmd := exec.Command(exePath, args...)

	// Prepare input for potential prompts (e.g., folders to exclude).
	input := bytes.NewBufferString("\n") // Provide an empty input for excluded folders.
	runCmd.Stdin = input

	// Capture standard output and standard error.
	var stdout, stderr bytes.Buffer
	runCmd.Stdout = &stdout
	runCmd.Stderr = &stderr

	// Execute the command.
	if err := runCmd.Run(); err != nil {
		t.Fatalf("Command failed: %v\nStdout: %s\nStderr: %s", err, stdout.String(), stderr.String())
	}

	// Step 5: Verify that the output file exists.
	outputFile := filepath.Join(outputDir, "repo-to-txt.txt")
	if _, err := os.Stat(outputFile); os.IsNotExist(err) {
		t.Errorf("Expected output file %s to exist", outputFile)
	}

	// Step 6: Optionally, read and verify the contents of the output file.
	content, err := ioutil.ReadFile(outputFile)
	if err != nil {
		t.Fatalf("Failed to read output file: %v", err)
	}

	if len(content) == 0 {
		t.Errorf("Output file %s is empty", outputFile)
	}

	// New Step: Verify clipboard content (optional and environment-dependent)
	if os.Getenv("RUN_CLIPBOARD_TESTS") == "true" {
		clipboardContent, err := clipboard.ReadAll()
		if err != nil {
			t.Fatalf("Failed to read from clipboard: %v", err)
		}

		// Simple comparison; in real tests, consider more robust checks
		if !strings.Contains(string(clipboardContent), "=== repo-to-txt.txt ===") {
			t.Errorf("Clipboard content does not contain expected output")
		}
	}
}


=== go.mod ===
module github.com/vytautas-bunevicius/repo-to-txt

go 1.21

toolchain go1.22.4

require (
	github.com/atotto/clipboard v0.1.4
	github.com/charmbracelet/huh v0.6.0
	github.com/go-git/go-git/v5 v5.12.0
)

require (
	dario.cat/mergo v1.0.0 // indirect
	github.com/Microsoft/go-winio v0.6.1 // indirect
	github.com/ProtonMail/go-crypto v1.0.0 // indirect
	github.com/aymanbagabas/go-osc52/v2 v2.0.1 // indirect
	github.com/catppuccin/go v0.2.0 // indirect
	github.com/charmbracelet/bubbles v0.20.0 // indirect
	github.com/charmbracelet/bubbletea v1.1.0 // indirect
	github.com/charmbracelet/lipgloss v0.13.0 // indirect
	github.com/charmbracelet/x/ansi v0.2.3 // indirect
	github.com/charmbracelet/x/exp/strings v0.0.0-20240722160745-212f7b056ed0 // indirect
	github.com/charmbracelet/x/term v0.2.0 // indirect
	github.com/cloudflare/circl v1.3.7 // indirect
	github.com/cyphar/filepath-securejoin v0.2.4 // indirect
	github.com/dustin/go-humanize v1.0.1 // indirect
	github.com/emirpasic/gods v1.18.1 // indirect
	github.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f // indirect
	github.com/go-git/gcfg v1.5.1-0.20230307220236-3a3c6141e376 // indirect
	github.com/go-git/go-billy/v5 v5.5.0 // indirect
	github.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da // indirect
	github.com/jbenet/go-context v0.0.0-20150711004518-d14ea06fba99 // indirect
	github.com/kevinburke/ssh_config v1.2.0 // indirect
	github.com/lucasb-eyer/go-colorful v1.2.0 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/mattn/go-localereader v0.0.1 // indirect
	github.com/mattn/go-runewidth v0.0.16 // indirect
	github.com/mitchellh/hashstructure/v2 v2.0.2 // indirect
	github.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6 // indirect
	github.com/muesli/cancelreader v0.2.2 // indirect
	github.com/muesli/termenv v0.15.3-0.20240618155329-98d742f6907a // indirect
	github.com/pjbgf/sha1cd v0.3.0 // indirect
	github.com/rivo/uniseg v0.4.7 // indirect
	github.com/sergi/go-diff v1.3.2-0.20230802210424-5b0b94c5c0d3 // indirect
	github.com/skeema/knownhosts v1.2.2 // indirect
	github.com/xanzy/ssh-agent v0.3.3 // indirect
	golang.org/x/crypto v0.23.0 // indirect
	golang.org/x/mod v0.17.0 // indirect
	golang.org/x/net v0.25.0 // indirect
	golang.org/x/sync v0.8.0 // indirect
	golang.org/x/sys v0.25.0 // indirect
	golang.org/x/text v0.18.0 // indirect
	golang.org/x/tools v0.21.1-0.20240508182429-e35e4ccd0d2d // indirect
	gopkg.in/warnings.v0 v0.1.2 // indirect
)


=== go.sum ===
dario.cat/mergo v1.0.0 h1:AGCNq9Evsj31mOgNPcLyXc+4PNABt905YmuqPYYpBWk=
dario.cat/mergo v1.0.0/go.mod h1:uNxQE+84aUszobStD9th8a29P2fMDhsBdgRYvZOxGmk=
github.com/MakeNowJust/heredoc v1.0.0 h1:cXCdzVdstXyiTqTvfqk9SDHpKNjxuom+DOlyEeQ4pzQ=
github.com/MakeNowJust/heredoc v1.0.0/go.mod h1:mG5amYoWBHf8vpLOuehzbGGw0EHxpZZ6lCpQ4fNJ8LE=
github.com/Microsoft/go-winio v0.5.2/go.mod h1:WpS1mjBmmwHBEWmogvA2mj8546UReBk4v8QkMxJ6pZY=
github.com/Microsoft/go-winio v0.6.1 h1:9/kr64B9VUZrLm5YYwbGtUJnMgqWVOdUAXu6Migciow=
github.com/Microsoft/go-winio v0.6.1/go.mod h1:LRdKpFKfdobln8UmuiYcKPot9D2v6svN5+sAH+4kjUM=
github.com/ProtonMail/go-crypto v1.0.0 h1:LRuvITjQWX+WIfr930YHG2HNfjR1uOfyf5vE0kC2U78=
github.com/ProtonMail/go-crypto v1.0.0/go.mod h1:EjAoLdwvbIOoOQr3ihjnSoLZRtE8azugULFRteWMNc0=
github.com/anmitsu/go-shlex v0.0.0-20200514113438-38f4b401e2be h1:9AeTilPcZAjCFIImctFaOjnTIavg87rW78vTPkQqLI8=
github.com/anmitsu/go-shlex v0.0.0-20200514113438-38f4b401e2be/go.mod h1:ySMOLuWl6zY27l47sB3qLNK6tF2fkHG55UZxx8oIVo4=
github.com/armon/go-socks5 v0.0.0-20160902184237-e75332964ef5 h1:0CwZNZbxp69SHPdPJAN/hZIm0C4OItdklCFmMRWYpio=
github.com/armon/go-socks5 v0.0.0-20160902184237-e75332964ef5/go.mod h1:wHh0iHkYZB8zMSxRWpUBQtwG5a7fFgvEO+odwuTv2gs=
github.com/atotto/clipboard v0.1.4 h1:EH0zSVneZPSuFR11BlR9YppQTVDbh5+16AmcJi4g1z4=
github.com/atotto/clipboard v0.1.4/go.mod h1:ZY9tmq7sm5xIbd9bOK4onWV4S6X0u6GY7Vn0Yu86PYI=
github.com/aymanbagabas/go-osc52/v2 v2.0.1 h1:HwpRHbFMcZLEVr42D4p7XBqjyuxQH5SMiErDT4WkJ2k=
github.com/aymanbagabas/go-osc52/v2 v2.0.1/go.mod h1:uYgXzlJ7ZpABp8OJ+exZzJJhRNQ2ASbcXHWsFqH8hp8=
github.com/bwesterb/go-ristretto v1.2.3/go.mod h1:fUIoIZaG73pV5biE2Blr2xEzDoMj7NFEuV9ekS419A0=
github.com/catppuccin/go v0.2.0 h1:ktBeIrIP42b/8FGiScP9sgrWOss3lw0Z5SktRoithGA=
github.com/catppuccin/go v0.2.0/go.mod h1:8IHJuMGaUUjQM82qBrGNBv7LFq6JI3NnQCF6MOlZjpc=
github.com/charmbracelet/bubbles v0.20.0 h1:jSZu6qD8cRQ6k9OMfR1WlM+ruM8fkPWkHvQWD9LIutE=
github.com/charmbracelet/bubbles v0.20.0/go.mod h1:39slydyswPy+uVOHZ5x/GjwVAFkCsV8IIVy+4MhzwwU=
github.com/charmbracelet/bubbletea v1.1.0 h1:FjAl9eAL3HBCHenhz/ZPjkKdScmaS5SK69JAK2YJK9c=
github.com/charmbracelet/bubbletea v1.1.0/go.mod h1:9Ogk0HrdbHolIKHdjfFpyXJmiCzGwy+FesYkZr7hYU4=
github.com/charmbracelet/huh v0.6.0 h1:mZM8VvZGuE0hoDXq6XLxRtgfWyTI3b2jZNKh0xWmax8=
github.com/charmbracelet/huh v0.6.0/go.mod h1:GGNKeWCeNzKpEOh/OJD8WBwTQjV3prFAtQPpLv+AVwU=
github.com/charmbracelet/lipgloss v0.13.0 h1:4X3PPeoWEDCMvzDvGmTajSyYPcZM4+y8sCA/SsA3cjw=
github.com/charmbracelet/lipgloss v0.13.0/go.mod h1:nw4zy0SBX/F/eAO1cWdcvy6qnkDUxr8Lw7dvFrAIbbY=
github.com/charmbracelet/x/ansi v0.2.3 h1:VfFN0NUpcjBRd4DnKfRaIRo53KRgey/nhOoEqosGDEY=
github.com/charmbracelet/x/ansi v0.2.3/go.mod h1:dk73KoMTT5AX5BsX0KrqhsTqAnhZZoCBjs7dGWp4Ktw=
github.com/charmbracelet/x/exp/strings v0.0.0-20240722160745-212f7b056ed0 h1:qko3AQ4gK1MTS/de7F5hPGx6/k1u0w4TeYmBFwzYVP4=
github.com/charmbracelet/x/exp/strings v0.0.0-20240722160745-212f7b056ed0/go.mod h1:pBhA0ybfXv6hDjQUZ7hk1lVxBiUbupdw5R31yPUViVQ=
github.com/charmbracelet/x/term v0.2.0 h1:cNB9Ot9q8I711MyZ7myUR5HFWL/lc3OpU8jZ4hwm0x0=
github.com/charmbracelet/x/term v0.2.0/go.mod h1:GVxgxAbjUrmpvIINHIQnJJKpMlHiZ4cktEQCN6GWyF0=
github.com/cloudflare/circl v1.3.3/go.mod h1:5XYMA4rFBvNIrhs50XuiBJ15vF2pZn4nnUKZrLbUZFA=
github.com/cloudflare/circl v1.3.7 h1:qlCDlTPz2n9fu58M0Nh1J/JzcFpfgkFHHX3O35r5vcU=
github.com/cloudflare/circl v1.3.7/go.mod h1:sRTcRWXGLrKw6yIGJ+l7amYJFfAXbZG0kBSc8r4zxgA=
github.com/cyphar/filepath-securejoin v0.2.4 h1:Ugdm7cg7i6ZK6x3xDF1oEu1nfkyfH53EtKeQYTC3kyg=
github.com/cyphar/filepath-securejoin v0.2.4/go.mod h1:aPGpWjXOXUn2NCNjFvBE6aRxGGx79pTxQpKOJNYHHl4=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/dustin/go-humanize v1.0.1 h1:GzkhY7T5VNhEkwH0PVJgjz+fX1rhBrR7pRT3mDkpeCY=
github.com/dustin/go-humanize v1.0.1/go.mod h1:Mu1zIs6XwVuF/gI1OepvI0qD18qycQx+mFykh5fBlto=
github.com/elazarl/goproxy v0.0.0-20230808193330-2592e75ae04a h1:mATvB/9r/3gvcejNsXKSkQ6lcIaNec2nyfOdlTBR2lU=
github.com/elazarl/goproxy v0.0.0-20230808193330-2592e75ae04a/go.mod h1:Ro8st/ElPeALwNFlcTpWmkr6IoMFfkjXAvTHpevnDsM=
github.com/emirpasic/gods v1.18.1 h1:FXtiHYKDGKCW2KzwZKx0iC0PQmdlorYgdFG9jPXJ1Bc=
github.com/emirpasic/gods v1.18.1/go.mod h1:8tpGGwCnJ5H4r6BWwaV6OrWmMoPhUl5jm/FMNAnJvWQ=
github.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f h1:Y/CXytFA4m6baUTXGLOoWe4PQhGxaX0KpnayAqC48p4=
github.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f/go.mod h1:vw97MGsxSvLiUE2X8qFplwetxpGLQrlU1Q9AUEIzCaM=
github.com/gliderlabs/ssh v0.3.7 h1:iV3Bqi942d9huXnzEF2Mt+CY9gLu8DNM4Obd+8bODRE=
github.com/gliderlabs/ssh v0.3.7/go.mod h1:zpHEXBstFnQYtGnB8k8kQLol82umzn/2/snG7alWVD8=
github.com/go-git/gcfg v1.5.1-0.20230307220236-3a3c6141e376 h1:+zs/tPmkDkHx3U66DAb0lQFJrpS6731Oaa12ikc+DiI=
github.com/go-git/gcfg v1.5.1-0.20230307220236-3a3c6141e376/go.mod h1:an3vInlBmSxCcxctByoQdvwPiA7DTK7jaaFDBTtu0ic=
github.com/go-git/go-billy/v5 v5.5.0 h1:yEY4yhzCDuMGSv83oGxiBotRzhwhNr8VZyphhiu+mTU=
github.com/go-git/go-billy/v5 v5.5.0/go.mod h1:hmexnoNsr2SJU1Ju67OaNz5ASJY3+sHgFRpCtpDCKow=
github.com/go-git/go-git-fixtures/v4 v4.3.2-0.20231010084843-55a94097c399 h1:eMje31YglSBqCdIqdhKBW8lokaMrL3uTkpGYlE2OOT4=
github.com/go-git/go-git-fixtures/v4 v4.3.2-0.20231010084843-55a94097c399/go.mod h1:1OCfN199q1Jm3HZlxleg+Dw/mwps2Wbk9frAWm+4FII=
github.com/go-git/go-git/v5 v5.12.0 h1:7Md+ndsjrzZxbddRDZjF14qK+NN56sy6wkqaVrjZtys=
github.com/go-git/go-git/v5 v5.12.0/go.mod h1:FTM9VKtnI2m65hNI/TenDDDnUf2Q9FHnXYjuz9i5OEY=
github.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da h1:oI5xCqsCo564l8iNU+DwB5epxmsaqB+rhGL0m5jtYqE=
github.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=
github.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=
github.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=
github.com/jbenet/go-context v0.0.0-20150711004518-d14ea06fba99 h1:BQSFePA1RWJOlocH6Fxy8MmwDt+yVQYULKfN0RoTN8A=
github.com/jbenet/go-context v0.0.0-20150711004518-d14ea06fba99/go.mod h1:1lJo3i6rXxKeerYnT8Nvf0QmHCRC1n8sfWVwXF2Frvo=
github.com/kevinburke/ssh_config v1.2.0 h1:x584FjTGwHzMwvHx18PXxbBVzfnxogHaAReU4gf13a4=
github.com/kevinburke/ssh_config v1.2.0/go.mod h1:CT57kijsi8u/K/BOFA39wgDQJ9CxiF4nAY/ojJ6r6mM=
github.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=
github.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=
github.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=
github.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=
github.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=
github.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=
github.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=
github.com/lucasb-eyer/go-colorful v1.2.0 h1:1nnpGOrhyZZuNyfu1QjKiUICQ74+3FNCN69Aj6K7nkY=
github.com/lucasb-eyer/go-colorful v1.2.0/go.mod h1:R4dSotOR9KMtayYi1e77YzuveK+i7ruzyGqttikkLy0=
github.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=
github.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=
github.com/mattn/go-localereader v0.0.1 h1:ygSAOl7ZXTx4RdPYinUpg6W99U8jWvWi9Ye2JC/oIi4=
github.com/mattn/go-localereader v0.0.1/go.mod h1:8fBrzywKY7BI3czFoHkuzRoWE9C+EiG4R1k4Cjx5p88=
github.com/mattn/go-runewidth v0.0.16 h1:E5ScNMtiwvlvB5paMFdw9p4kSQzbXFikJ5SQO6TULQc=
github.com/mattn/go-runewidth v0.0.16/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=
github.com/mitchellh/hashstructure/v2 v2.0.2 h1:vGKWl0YJqUNxE8d+h8f6NJLcCJrgbhC4NcD46KavDd4=
github.com/mitchellh/hashstructure/v2 v2.0.2/go.mod h1:MG3aRVU/N29oo/V/IhBX8GR/zz4kQkprJgF2EVszyDE=
github.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6 h1:ZK8zHtRHOkbHy6Mmr5D264iyp3TiX5OmNcI5cIARiQI=
github.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6/go.mod h1:CJlz5H+gyd6CUWT45Oy4q24RdLyn7Md9Vj2/ldJBSIo=
github.com/muesli/cancelreader v0.2.2 h1:3I4Kt4BQjOR54NavqnDogx/MIoWBFa0StPA8ELUXHmA=
github.com/muesli/cancelreader v0.2.2/go.mod h1:3XuTXfFS2VjM+HTLZY9Ak0l6eUKfijIfMUZ4EgX0QYo=
github.com/muesli/termenv v0.15.3-0.20240618155329-98d742f6907a h1:2MaM6YC3mGu54x+RKAA6JiFFHlHDY1UbkxqppT7wYOg=
github.com/muesli/termenv v0.15.3-0.20240618155329-98d742f6907a/go.mod h1:hxSnBBYLK21Vtq/PHd0S2FYCxBXzBua8ov5s1RobyRQ=
github.com/onsi/gomega v1.27.10 h1:naR28SdDFlqrG6kScpT8VWpu1xWY5nJRCF3XaYyBjhI=
github.com/onsi/gomega v1.27.10/go.mod h1:RsS8tutOdbdgzbPtzzATp12yT7kM5I5aElG3evPbQ0M=
github.com/pjbgf/sha1cd v0.3.0 h1:4D5XXmUUBUl/xQ6IjCkEAbqXskkq/4O7LmGn0AqMDs4=
github.com/pjbgf/sha1cd v0.3.0/go.mod h1:nZ1rrWOcGJ5uZgEEVL1VUM9iRQiZvWdbZjkKyFzPPsI=
github.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=
github.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=
github.com/rivo/uniseg v0.4.7 h1:WUdvkW8uEhrYfLC4ZzdpI2ztxP1I582+49Oc5Mq64VQ=
github.com/rivo/uniseg v0.4.7/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=
github.com/rogpeppe/go-internal v1.11.0 h1:cWPaGQEPrBb5/AsnsZesgZZ9yb1OQ+GOISoDNXVBh4M=
github.com/rogpeppe/go-internal v1.11.0/go.mod h1:ddIwULY96R17DhadqLgMfk9H9tvdUzkipdSkR5nkCZA=
github.com/sergi/go-diff v1.3.2-0.20230802210424-5b0b94c5c0d3 h1:n661drycOFuPLCN3Uc8sB6B/s6Z4t2xvBgU1htSHuq8=
github.com/sergi/go-diff v1.3.2-0.20230802210424-5b0b94c5c0d3/go.mod h1:A0bzQcvG0E7Rwjx0REVgAGH58e96+X0MeOfepqsbeW4=
github.com/sirupsen/logrus v1.7.0/go.mod h1:yWOB1SBYBC5VeMP7gHvWumXLIWorT60ONWic61uBYv0=
github.com/skeema/knownhosts v1.2.2 h1:Iug2P4fLmDw9f41PB6thxUkNUkJzB5i+1/exaj40L3A=
github.com/skeema/knownhosts v1.2.2/go.mod h1:xYbVRSPxqBZFrdmDyMmsOs+uX1UZC3nTN3ThzgDxUwo=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=
github.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=
github.com/stretchr/testify v1.9.0 h1:HtqpIVDClZ4nwg75+f6Lvsy/wHu+3BoSGCbBAcpTsTg=
github.com/stretchr/testify v1.9.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=
github.com/xanzy/ssh-agent v0.3.3 h1:+/15pJfg/RsTxqYcX6fHqOXZwwMP+2VyYWJeWM2qQFM=
github.com/xanzy/ssh-agent v0.3.3/go.mod h1:6dzNDKs0J9rVPHPhaGCukekBHKqfl+L3KghI1Bc68Uw=
github.com/yuin/goldmark v1.4.13/go.mod h1:6yULJ656Px+3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=
golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
golang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=
golang.org/x/crypto v0.0.0-20220622213112-05595931fe9d/go.mod h1:IxCIyHEi3zRg3s0A5j5BB6A9Jmi73HwBIUl50j+osU4=
golang.org/x/crypto v0.3.1-0.20221117191849-2c476679df9a/go.mod h1:hebNnKkNXi2UzZN1eVRvBB7co0a+JxK6XbPiWVs/3J4=
golang.org/x/crypto v0.7.0/go.mod h1:pYwdfH91IfpZVANVyUOhSIPZaFoJGxTFbZhFTx+dXZU=
golang.org/x/crypto v0.23.0 h1:dIJU/v2J8Mdglj/8rJ6UUOM3Zc9zLZxVZwwxMooUSAI=
golang.org/x/crypto v0.23.0/go.mod h1:CKFgDieR+mRhux2Lsu27y0fO304Db0wZe70UKqHu0v8=
golang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=
golang.org/x/mod v0.8.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=
golang.org/x/mod v0.17.0 h1:zY54UmvipHiNd+pm+m0x9KhZ9hl1/7QNMyxXbc6ICqA=
golang.org/x/mod v0.17.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=
golang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=
golang.org/x/net v0.0.0-20211112202133-69e39bad7dc2/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=
golang.org/x/net v0.0.0-20220722155237-a158d28d115b/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=
golang.org/x/net v0.2.0/go.mod h1:KqCZLdyyvdV855qA2rE3GC2aiw5xGR5TEjj8smXukLY=
golang.org/x/net v0.6.0/go.mod h1:2Tu9+aMcznHK/AK1HMvgo6xiTLG5rD5rZLDS+rp2Bjs=
golang.org/x/net v0.8.0/go.mod h1:QVkue5JL9kW//ek3r6jTKnTFis1tRmNAW2P1shuFdJc=
golang.org/x/net v0.25.0 h1:d/OCCoBEUq33pjydKrGQhw7IlUPI2Oylr+8qLx49kac=
golang.org/x/net v0.25.0/go.mod h1:JkAGAh7GEvH74S6FOH42FLoXpXbE/aqXSrIQjXgsiwM=
golang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.1.0/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.8.0 h1:3NFvSEYkUoMifnESzZl15y791HH1qU2xm6eCJU5ZPXQ=
golang.org/x/sync v0.8.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=
golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20191026070338-33540a1f6037/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210124154548-22da62e12c0c/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210423082822-04245dca01da/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20210809222454-d867a43fc93e/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220715151400-c0bba94af5f8/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.2.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.3.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.25.0 h1:r+8e+loiHxRqhXVl6ML1nO3l1+oFoWbnlu2Ehimmi34=
golang.org/x/sys v0.25.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=
golang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=
golang.org/x/term v0.2.0/go.mod h1:TVmDHMZPmdnySmBfhjOoOdhjzdE1h4u1VwSiw2l1Nuc=
golang.org/x/term v0.5.0/go.mod h1:jMB1sMXY+tzblOD4FWmEbocvup2/aLOaQEp7JmGp78k=
golang.org/x/term v0.6.0/go.mod h1:m6U89DPEgQRMq3DNkDClhWw02AUbt2daBVO4cn4Hv9U=
golang.org/x/term v0.20.0 h1:VnkxpohqXaOBYJtBmEppKUG6mXpi+4O6purfc2+sMhw=
golang.org/x/term v0.20.0/go.mod h1:8UkIAJTvZgivsXaD6/pH6U9ecQzZ45awqEOzuCvwpFY=
golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
golang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/text v0.3.6/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=
golang.org/x/text v0.4.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=
golang.org/x/text v0.7.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=
golang.org/x/text v0.8.0/go.mod h1:e1OnstbJyHTd6l/uOt8jFFHp6TRDWZR/bV3emEE/zU8=
golang.org/x/text v0.18.0 h1:XvMDiNzPAl0jr17s6W9lcaIhGUfUORdGCNsuLmPG224=
golang.org/x/text v0.18.0/go.mod h1:BuEKDfySbSR4drPmRPG/7iBdf8hvFMuRexcpahXilzY=
golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=
golang.org/x/tools v0.6.0/go.mod h1:Xwgl3UAJ/d3gWutnCtw505GrjyAbvKui8lOU390QaIU=
golang.org/x/tools v0.21.1-0.20240508182429-e35e4ccd0d2d h1:vU5i/LfpvrRCpgM/VPfJLg5KjxD3E+hfT1SH+d9zLwg=
golang.org/x/tools v0.21.1-0.20240508182429-e35e4ccd0d2d/go.mod h1:aiJjzUbINMkxbQROHiO6hDPo2LHcIPhhQsa9DLh0yGk=
golang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=
gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=
gopkg.in/warnings.v0 v0.1.2 h1:wFXVbFY8DY5/xOe1ECiWdKCzZlxgshcYVNkBHstARME=
gopkg.in/warnings.v0 v0.1.2/go.mod h1:jksf8JmL6Qr/oQM2OXTHunEvvTAsrWBLb6OOjuVWRNI=
gopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v2 v2.4.0/go.mod h1:RDklbk79AGWmwhnvt/jBztapEOGDOx6ZbXqjP6csGnQ=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=


=== pkg/auth/auth.go ===
// Package auth provides authentication methods for interacting with Git repositories.
// It supports HTTPS and SSH authentication mechanisms based on the provided configuration.
package auth

import (
	"errors"

	"github.com/go-git/go-git/v5/plumbing/transport"
	"github.com/go-git/go-git/v5/plumbing/transport/http"
	"github.com/go-git/go-git/v5/plumbing/transport/ssh"
	"github.com/vytautas-bunevicius/repo-to-txt/pkg/config"
)

// SetupAuth prepares the appropriate authentication method based on the provided configuration.
// It returns a transport.AuthMethod suitable for the chosen authentication type or an error if the setup fails.
//
// Parameters:
//   - cfg: A pointer to the Config struct containing authentication details.
//
// Returns:
//   - transport.AuthMethod: The configured authentication method.
//   - error: An error if the authentication setup fails.
func SetupAuth(cfg *config.Config) (transport.AuthMethod, error) {
	switch cfg.AuthMethod {
	case config.AuthMethodHTTPS:
		if cfg.Username == "" || cfg.PersonalAccessToken == "" {
			return nil, errors.New("username and personal access token must be provided for HTTPS authentication")
		}
		return &http.BasicAuth{
			Username: cfg.Username,
			Password: cfg.PersonalAccessToken,
		}, nil
	case config.AuthMethodSSH:
		if cfg.SSHPassphrase != "" {
			return ssh.NewPublicKeys(config.DefaultSSHKeyName, []byte(cfg.SSHPassphrase), cfg.SSHKeyPath)
		}
		return ssh.NewPublicKeysFromFile(config.DefaultSSHKeyName, cfg.SSHKeyPath, "")
	case config.AuthMethodNone:
		return nil, nil
	default:
		return nil, errors.New("unsupported authentication method")
	}
}


=== pkg/auth/auth_test.go ===
// Package auth_test contains unit tests for the auth package.
package auth

import (
	"testing"

	"github.com/go-git/go-git/v5/plumbing/transport/ssh" // Added import for ssh package
	"github.com/vytautas-bunevicius/repo-to-txt/pkg/config"
)

// TestSetupAuth verifies that the SetupAuth function correctly sets up the authentication method
// based on different configuration scenarios.
func TestSetupAuth(t *testing.T) {
	// Test HTTPS Authentication
	cfgHTTPS := &config.Config{
		AuthMethod:          config.AuthMethodHTTPS,
		Username:            "testuser",
		PersonalAccessToken: "testtoken",
	}
	authMethodHTTPS, err := SetupAuth(cfgHTTPS)
	if err != nil {
		t.Fatalf("SetupAuth returned an error: %v", err)
	}

	if authMethodHTTPS == nil {
		t.Errorf("Expected HTTPS AuthMethod, got nil")
	}

	// Assert that authMethodHTTPS is of type *ssh.PublicKeys
	// Note: In go-git, HTTPS uses http.BasicAuth, not ssh.PublicKeys.
	// Correcting the expectation.
	if _, ok := authMethodHTTPS.(*ssh.PublicKeys); ok {
		t.Errorf("Expected HTTPS AuthMethod to be of type *http.BasicAuth, got *ssh.PublicKeys")
	}

	// Test SSH Authentication without passphrase
	cfgSSH := &config.Config{
		AuthMethod: config.AuthMethodSSH,
		SSHKeyPath: "/path/to/ssh/key",
	}
	authMethodSSH, err := SetupAuth(cfgSSH)
	if err != nil {
		t.Fatalf("SetupAuth returned an error: %v", err)
	}

	if authMethodSSH == nil {
		t.Errorf("Expected SSH AuthMethod, got nil")
	}

	// Assert that authMethodSSH is of type *ssh.PublicKeys
	if _, ok := authMethodSSH.(*ssh.PublicKeys); !ok {
		t.Errorf("Expected SSH AuthMethod to be of type *ssh.PublicKeys, got %T", authMethodSSH)
	}

	// Test SSH Authentication with passphrase
	cfgSSHPass := &config.Config{
		AuthMethod:    config.AuthMethodSSH,
		SSHKeyPath:    "/path/to/ssh/key",
		SSHPassphrase: "passphrase",
	}
	authMethodSSHPass, err := SetupAuth(cfgSSHPass)
	if err != nil {
		t.Fatalf("SetupAuth returned an error: %v", err)
	}

	if authMethodSSHPass == nil {
		t.Errorf("Expected SSH AuthMethod with passphrase, got nil")
	}

	// Assert that authMethodSSHPass is of type *ssh.PublicKeys
	if _, ok := authMethodSSHPass.(*ssh.PublicKeys); !ok {
		t.Errorf("Expected SSH AuthMethod to be of type *ssh.PublicKeys, got %T", authMethodSSHPass)
	}

	// Test No Authentication
	cfgNone := &config.Config{
		AuthMethod: config.AuthMethodNone,
	}
	authMethodNone, err := SetupAuth(cfgNone)
	if err != nil {
		t.Fatalf("SetupAuth returned an error: %v", err)
	}

	if authMethodNone != nil {
		t.Errorf("Expected No AuthMethod to be nil, got %T", authMethodNone)
	}

	// Test Missing HTTPS Credentials
	cfgMissingHTTPS := &config.Config{
		AuthMethod: config.AuthMethodHTTPS,
	}
	_, err = SetupAuth(cfgMissingHTTPS)
	if err == nil {
		t.Errorf("Expected error for missing HTTPS credentials, got nil")
	}

	// Test Unsupported Authentication Method
	cfgInvalid := &config.Config{
		AuthMethod: 999, // Invalid AuthMethod
	}
	_, err = SetupAuth(cfgInvalid)
	if err == nil {
		t.Errorf("Expected error for unsupported authentication method, got nil")
	}
}


=== pkg/clone/clone.go ===
// Package clone handles the cloning and updating of Git repositories.
// It provides functionalities to clone a repository or pull the latest changes if it already exists locally.
package clone

import (
	"context"
	"errors"
	"fmt"
	"net/url"
	"os"
	"path/filepath"
	"strings"

	"github.com/go-git/go-git/v5"
	"github.com/go-git/go-git/v5/plumbing/transport"
)

// ExtractRepoName extracts the repository name from the given repository URL.
// It supports both SSH and HTTPS URL formats.
//
// Parameters:
//   - repoURL: The URL of the Git repository.
//
// Returns:
//   - string: The extracted repository name.
//   - error: An error if the repository name cannot be determined.
func ExtractRepoName(repoURL string) (string, error) {
	if strings.HasPrefix(repoURL, "git@") {
		// Handle SSH URLs
		parts := strings.SplitN(repoURL, ":", 2)
		if len(parts) != 2 {
			return "", errors.New("invalid SSH repository URL format")
		}
		path := parts[1]
		repoPath := strings.TrimSuffix(path, ".git")
		repoName := filepath.Base(repoPath)
		if repoName == "" {
			return "", errors.New("could not determine repository name from URL")
		}
		return repoName, nil
	} else if strings.HasPrefix(repoURL, "https://") || strings.HasPrefix(repoURL, "http://") {
		// Handle HTTPS URLs
		u, err := url.Parse(repoURL)
		if err != nil {
			return "", fmt.Errorf("invalid repository URL: %w", err)
		}
		repoPath := strings.TrimSuffix(u.Path, ".git")
		repoName := filepath.Base(repoPath)
		if repoName == "" {
			return "", errors.New("could not determine repository name from URL")
		}
		return repoName, nil
	} else {
		return "", errors.New("invalid repository URL format")
	}
}

// CloneOrPullRepo clones the repository from the provided URL into the specified path.
// If the repository already exists locally, it attempts to pull the latest changes.
//
// Parameters:
//   - ctx: The context for the operation.
//   - repoURL: The URL of the Git repository.
//   - repoPath: The local file system path where the repository should be cloned.
//   - auth: The authentication method to use for accessing the repository.
//
// Returns:
//   - error: An error if the clone or pull operation fails.
func CloneOrPullRepo(ctx context.Context, repoURL, repoPath string, auth transport.AuthMethod) error {
	fmt.Printf("Cloning repository: %s\n", repoURL)
	_, err := git.PlainCloneContext(ctx, repoPath, false, &git.CloneOptions{
		URL:      repoURL,
		Progress: os.Stdout,
		Auth:     auth,
	})
	if err != nil {
		// If the repository already exists, attempt to pull the latest changes
		if errors.Is(err, git.ErrRepositoryAlreadyExists) {
			fmt.Println("Repository already exists. Attempting to pull latest changes.")
			repo, err := git.PlainOpen(repoPath)
			if err != nil {
				return fmt.Errorf("failed to open existing repository: %w", err)
			}
			w, err := repo.Worktree()
			if err != nil {
				return fmt.Errorf("failed to get worktree: %w", err)
			}
			err = w.Pull(&git.PullOptions{
				RemoteName: "origin",
				Progress:   os.Stdout,
				Auth:       auth,
			})
			if err != nil && err != git.NoErrAlreadyUpToDate {
				return fmt.Errorf("failed to pull repository: %w", err)
			}
			return nil
		}
		return fmt.Errorf("failed to clone repository: %w", err)
	}
	return nil
}


=== pkg/clone/clone_test.go ===
// Package clone_test contains unit tests for the clone package.
package clone

import (
	"testing"
)

// TestExtractRepoName verifies that the ExtractRepoName function correctly extracts
// repository names from various URL formats.
func TestExtractRepoName(t *testing.T) {
	testCases := []struct {
		repoURL  string
		expected string
		wantErr  bool
	}{
		{"https://github.com/user/repo.git", "repo", false},
		{"git@github.com:user/repo.git", "repo", false},
		{"invalid-url", "", true},
		{"ftp://github.com/user/repo.git", "", true},    // Invalid scheme
		{"https://github.com/user/repo", "repo", false}, // Without .git
		{"git@github.com:user/repo", "repo", false},     // SSH without .git
	}

	for _, tc := range testCases {
		t.Run(tc.repoURL, func(t *testing.T) {
			result, err := ExtractRepoName(tc.repoURL)
			if (err != nil) != tc.wantErr {
				t.Errorf("ExtractRepoName(%q) error = %v, wantErr %v", tc.repoURL, err, tc.wantErr)
				return
			}
			if result != tc.expected {
				t.Errorf("ExtractRepoName(%q) = %q; want %q", tc.repoURL, result, tc.expected)
			}
		})
	}
}


=== pkg/config/config.go ===
// Package config handles the configuration for the repo-to-txt CLI tool.
// It defines the structure for storing configuration options and provides
// methods for parsing command-line flags and environment variables.
package config

import (
	"errors"
	"flag"
	"fmt"
	"os"
	"strings"
)

// Constants define default values and version information for the tool.
const (
	// Version represents the current version of the tool.
	Version = "1.1.0"

	// DefaultCloneDir is the default directory name for cloning repositories.
	DefaultCloneDir = "repo-to-txt-clone"

	// DefaultOutputExt is the default file extension for the output file.
	DefaultOutputExt = ".txt"

	// DefaultSSHKeyName is the default name for the SSH key file.
	DefaultSSHKeyName = "git"

	// DefaultExcludedExt is the default file extension to exclude from processing.
	DefaultExcludedExt = ".ipynb"
)

// AuthMethod represents the type of authentication to use when accessing repositories.
type AuthMethod int

// Constants for different authentication methods.
const (
	AuthMethodNone AuthMethod = iota
	AuthMethodHTTPS
	AuthMethodSSH
)

// Config holds all configuration options for the repo-to-txt tool.
type Config struct {
	RepoURL             string     // URL of the Git repository to clone
	AuthMethod          AuthMethod // Authentication method to use
	Username            string     // GitHub username for HTTPS authentication
	PersonalAccessToken string     // GitHub personal access token for HTTPS authentication
	SSHKeyPath          string     // Path to SSH key for SSH authentication
	SSHPassphrase       string     // Passphrase for SSH key, if any
	ExcludeFolders      []string   // List of folders to exclude from processing
	IncludeExt          []string   // List of file extensions to include in processing
	FileNames           []string   // List of exact file names to copy from the repository
	OutputDir           string     // Directory to output the generated text file
	AuthFlagSet         bool       // Indicates if authentication method was set via flag
	VersionFlag         bool       // Flag to print version information
	CopyToClipboard     bool       // Flag to copy output to clipboard
	CopyToClipboardSet  bool       // Indicates if copy-to-clipboard was set via flag
}

// NewConfig creates and returns a new Config instance with default values.
func NewConfig() *Config {
	return &Config{}
}

// ParseFlags parses command-line flags and populates the Config struct.
// It handles required flags, default values, and validates authentication methods.
func (cfg *Config) ParseFlags() error {
	var authMethod string
	var excludeFolders, includeExt, files string

	// Define command-line flags
	flag.StringVar(&cfg.RepoURL, "repo", "", "GitHub repository URL (HTTPS or SSH) (Required)")
	flag.StringVar(&authMethod, "auth", "", "Authentication method: none, https, or ssh (Required)")
	flag.StringVar(&cfg.Username, "username", "", "GitHub username (for HTTPS)")
	flag.StringVar(&cfg.PersonalAccessToken, "pat", "", "GitHub Personal Access Token (for HTTPS)")
	flag.StringVar(&cfg.SSHKeyPath, "ssh-key", "", "Path to SSH private key (for SSH)")
	flag.StringVar(&cfg.OutputDir, "output-dir", "", "Output directory for the generated text file")
	flag.StringVar(&excludeFolders, "exclude", "", "Comma-separated list of folders to exclude from the output")
	flag.StringVar(&includeExt, "include-ext", "", "Comma-separated list of file extensions to include (e.g., .go,.md). If not set, defaults to excluding certain non-code files like .ipynb")
	flag.StringVar(&files, "files", "", "Comma-separated list of exact file names to copy from the repository")
	flag.BoolVar(&cfg.VersionFlag, "version", false, "Print the version number and exit")
	flag.BoolVar(&cfg.CopyToClipboard, "copy-clipboard", false, "Copy the output to clipboard")

	// Parse the flags
	flag.Parse()

	// Check if copy-to-clipboard was set via flag
	flag.Visit(func(f *flag.Flag) {
		if f.Name == "copy-clipboard" {
			cfg.CopyToClipboardSet = true
		}
		if f.Name == "auth" {
			cfg.AuthFlagSet = true
		}
	})

	// Handle version flag
	if cfg.VersionFlag {
		fmt.Printf("repo-to-txt version %s\n", Version)
		os.Exit(0)
	}

	// Process comma-separated inputs
	cfg.ExcludeFolders = parseCommaSeparated(excludeFolders)
	cfg.IncludeExt = parseCommaSeparated(includeExt)
	cfg.FileNames = parseCommaSeparated(files)

	// Set authentication method
	switch strings.ToLower(authMethod) {
	case "https":
		cfg.AuthMethod = AuthMethodHTTPS
	case "ssh":
		cfg.AuthMethod = AuthMethodSSH
	case "none", "":
		cfg.AuthMethod = AuthMethodNone
	default:
		return errors.New("invalid authentication method: choose from none, https, ssh")
	}

	return nil
}

// parseCommaSeparated splits a comma-separated string into a slice of trimmed strings.
// It returns nil if the input string is empty.
func parseCommaSeparated(input string) []string {
	if input == "" {
		return nil
	}
	parts := strings.Split(input, ",")
	result := make([]string, 0, len(parts))
	for _, part := range parts {
		if trimmed := strings.TrimSpace(part); trimmed != "" {
			result = append(result, trimmed)
		}
	}
	return result
}


=== pkg/config/config_test.go ===
// Package config_test contains unit tests for the config package.
package config

import (
	"os"
	"testing"
)

// TestParseFlags verifies that the ParseFlags method correctly parses command-line flags
// and populates the Config struct accordingly.
func TestParseFlags(t *testing.T) {
	originalArgs := os.Args
	defer func() { os.Args = originalArgs }()

	os.Args = []string{
		"cmd",
		"-repo=https://github.com/user/repo.git",
		"-auth=https",
		"-username=testuser",
		"-pat=testtoken",
		"-ssh-key=/path/to/ssh/key",
		"-output-dir=/path/to/output",
		"-exclude=docs,tests",
		"-include-ext=.go,.md",
		"-copy-clipboard=true",
	}

	cfg := NewConfig()
	if err := cfg.ParseFlags(); err != nil {
		t.Fatalf("ParseFlags returned an error: %v", err)
	}

	if cfg.RepoURL != "https://github.com/user/repo.git" {
		t.Errorf("Expected RepoURL to be %q, got %q", "https://github.com/user/repo.git", cfg.RepoURL)
	}

	if cfg.AuthMethod != AuthMethodHTTPS {
		t.Errorf("Expected AuthMethod to be HTTPS, got %v", cfg.AuthMethod)
	}

	if cfg.Username != "testuser" {
		t.Errorf("Expected Username to be %q, got %q", "testuser", cfg.Username)
	}

	if cfg.PersonalAccessToken != "testtoken" {
		t.Errorf("Expected PersonalAccessToken to be %q, got %q", "testtoken", cfg.PersonalAccessToken)
	}

	if cfg.SSHKeyPath != "/path/to/ssh/key" {
		t.Errorf("Expected SSHKeyPath to be %q, got %q", "/path/to/ssh/key", cfg.SSHKeyPath)
	}

	if cfg.OutputDir != "/path/to/output" {
		t.Errorf("Expected OutputDir to be %q, got %q", "/path/to/output", cfg.OutputDir)
	}

	expectedExcludes := []string{"docs", "tests"}
	if len(cfg.ExcludeFolders) != len(expectedExcludes) {
		t.Errorf("Expected ExcludeFolders length to be %d, got %d", len(expectedExcludes), len(cfg.ExcludeFolders))
	} else {
		for i, v := range expectedExcludes {
			if cfg.ExcludeFolders[i] != v {
				t.Errorf("Expected ExcludeFolders[%d] to be %q, got %q", i, v, cfg.ExcludeFolders[i])
			}
		}
	}

	expectedIncludes := []string{".go", ".md"}
	if len(cfg.IncludeExt) != len(expectedIncludes) {
		t.Errorf("Expected IncludeExt length to be %d, got %d", len(expectedIncludes), len(cfg.IncludeExt))
	} else {
		for i, v := range expectedIncludes {
			if cfg.IncludeExt[i] != v {
				t.Errorf("Expected IncludeExt[%d] to be %q, got %q", i, v, cfg.IncludeExt[i])
			}
		}
	}

	if !cfg.CopyToClipboard {
		t.Errorf("Expected CopyToClipboard to be true, got false")
	}
}

// TestParseFlagsDefaults verifies that default values are correctly set when certain flags are omitted.
func TestParseFlagsDefaults(t *testing.T) {
	originalArgs := os.Args
	defer func() { os.Args = originalArgs }()

	os.Args = []string{
		"cmd",
		"-repo=https://github.com/user/repo.git",
	}

	cfg := NewConfig()
	if err := cfg.ParseFlags(); err != nil {
		t.Fatalf("ParseFlags returned an error: %v", err)
	}

	if cfg.RepoURL != "https://github.com/user/repo.git" {
		t.Errorf("Expected RepoURL to be %q, got %q", "https://github.com/user/repo.git", cfg.RepoURL)
	}

	if cfg.AuthMethod != AuthMethodNone {
		t.Errorf("Expected AuthMethod to be None, got %v", cfg.AuthMethod)
	}

	if cfg.OutputDir != "" {
		t.Errorf("Expected OutputDir to be empty, got %q", cfg.OutputDir)
	}

	if len(cfg.ExcludeFolders) != 0 {
		t.Errorf("Expected ExcludeFolders to be empty, got %v", cfg.ExcludeFolders)
	}

	if len(cfg.IncludeExt) != 0 {
		t.Errorf("Expected IncludeExt to be empty, got %v", cfg.IncludeExt)
	}

	if cfg.CopyToClipboard {
		t.Errorf("Expected CopyToClipboard to be false, got true")
	}
}

// TestParseFlagsInvalidAuth verifies that an invalid authentication method results in an error.
func TestParseFlagsInvalidAuth(t *testing.T) {
	originalArgs := os.Args
	defer func() { os.Args = originalArgs }()

	os.Args = []string{
		"cmd",
		"-repo=https://github.com/user/repo.git",
		"-auth=invalid",
	}

	cfg := NewConfig()
	err := cfg.ParseFlags()
	if err == nil {
		t.Errorf("Expected ParseFlags to return an error for invalid auth method, got nil")
	}
}



=== pkg/output/output.go ===
// Package output manages the generation of the output text file containing repository contents.
// It handles writing file contents to the output file with appropriate formatting and exclusions,
// as well as copying specified files to the output directory.
package output

import (
	"bufio"
	"bytes"
	"errors"
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/vytautas-bunevicius/repo-to-txt/pkg/config"
	"github.com/vytautas-bunevicius/repo-to-txt/pkg/util"
)

// FindFiles searches for the specified file names within the repository directory.
//
// Parameters:
//   - repoPath: The local path of the cloned repository.
//   - fileNames: A slice of exact file names to search for.
//
// Returns:
//   - map[string][]string: A map where the key is the file name and the value is a slice of matching file paths.
//   - error: An error if the search fails.
func FindFiles(repoPath string, fileNames []string) (map[string][]string, error) {
	if len(fileNames) == 0 {
		return nil, errors.New("no file names provided to search for")
	}

	fileMatches := make(map[string][]string)

	err := filepath.Walk(repoPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			// Skip paths that can't be accessed
			log.Printf("Error accessing path %s: %v", path, err)
			return nil
		}

		if info.IsDir() || strings.HasPrefix(info.Name(), ".") {
			return nil // Skip directories and hidden files
		}

		for _, fileName := range fileNames {
			if strings.EqualFold(info.Name(), fileName) {
				fileMatches[fileName] = append(fileMatches[fileName], path)
			}
		}

		return nil
	})

	if err != nil {
		return nil, fmt.Errorf("error walking the path %s: %w", repoPath, err)
	}

	return fileMatches, nil
}

// WriteRepoContentsToFile writes the contents of the specified repository directory to an output file.
// It traverses the repository, applies exclusion rules, and formats the output with file separators.
//
// Parameters:
//   - repoPath: The local path of the cloned repository.
//   - outputFile: The path to the output text file.
//   - cfg: A pointer to the Config struct containing exclusion and inclusion rules.
//
// Returns:
//   - error: An error if writing to the file fails.
func WriteRepoContentsToFile(repoPath, outputFile string, cfg *config.Config) error {
	file, err := os.Create(outputFile)
	if err != nil {
		return fmt.Errorf("unable to create output file: %w", err)
	}
	defer file.Close()

	writer := bufio.NewWriter(file)
	defer writer.Flush()

	err = filepath.Walk(repoPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return fmt.Errorf("error accessing path %s: %w", path, err)
		}

		if info.IsDir() || strings.HasPrefix(info.Name(), ".") {
			return nil // Skip directories and hidden files
		}

		relPath, err := filepath.Rel(repoPath, path)
		if err != nil {
			return fmt.Errorf("error getting relative path: %w", err)
		}

		if shouldExcludeFile(relPath, cfg) {
			return nil // Skip excluded files
		}

		content, err := readFileContent(path)
		if err != nil {
			log.Printf("Skipping file %s: %v", relPath, err)
			return nil // Skip files that cannot be read or are binary
		}

		return writeFileContent(writer, relPath, content)
	})

	if err != nil {
		return fmt.Errorf("error walking the path %s: %w", repoPath, err)
	}

	return nil
}

// shouldExcludeFile determines whether a file should be excluded based on its relative path and extension.
// It checks against the excluded folders and included extensions specified in the configuration.
//
// Parameters:
//   - relPath: The relative path of the file within the repository.
//   - cfg: A pointer to the Config struct containing exclusion and inclusion rules.
//
// Returns:
//   - bool: True if the file should be excluded, false otherwise.
func shouldExcludeFile(relPath string, cfg *config.Config) bool {
	normalizedRelPath := filepath.ToSlash(relPath)
	for _, exclude := range cfg.ExcludeFolders {
		normalizedExclude := filepath.ToSlash(strings.TrimSpace(exclude))
		if normalizedExclude == "" {
			continue
		}
		if strings.HasPrefix(normalizedRelPath, normalizedExclude+"/") || normalizedRelPath == normalizedExclude {
			return true
		}
	}

	if len(cfg.IncludeExt) > 0 {
		ext := strings.ToLower(filepath.Ext(relPath))
		return !util.Contains(cfg.IncludeExt, ext)
	}

	return strings.HasSuffix(strings.ToLower(relPath), config.DefaultExcludedExt)
}

// readFileContent reads and returns the content of a file if it is a text file.
// It skips binary files by checking for null bytes.
//
// Parameters:
//   - path: The file system path to the file.
//
// Returns:
//   - []byte: The content of the file.
//   - error: An error if the file cannot be read or is identified as binary.
func readFileContent(path string) ([]byte, error) {
	file, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	buf := make([]byte, 512)
	n, err := file.Read(buf)
	if err != nil && err != io.EOF {
		return nil, err
	}
	if isBinary(buf[:n]) {
		return nil, errors.New("binary file")
	}

	if _, err := file.Seek(0, io.SeekStart); err != nil {
		return nil, err
	}

	return io.ReadAll(file)
}

// writeFileContent writes the content of a file to the output writer with appropriate formatting.
// It adds a separator with the relative file path before the content.
//
// Parameters:
//   - writer: The buffered writer for the output file.
//   - relPath: The relative path of the file within the repository.
//   - content: The content of the file.
//
// Returns:
//   - error: An error if writing to the output file fails.
func writeFileContent(writer *bufio.Writer, relPath string, content []byte) error {
	separator := fmt.Sprintf("=== %s ===\n", relPath)
	if _, err := io.WriteString(writer, separator); err != nil {
		return fmt.Errorf("error writing to output file: %w", err)
	}
	if _, err := writer.Write(content); err != nil {
		return fmt.Errorf("error writing file content: %w", err)
	}
	if _, err := io.WriteString(writer, "\n\n"); err != nil {
		return fmt.Errorf("error writing newline to output file: %w", err)
	}
	return nil
}

// isBinary checks if the provided byte slice contains any null bytes, indicating a binary file.
//
// Parameters:
//   - data: The byte slice to check.
//
// Returns:
//   - bool: True if the data is binary, false otherwise.
func isBinary(data []byte) bool {
	return bytes.IndexByte(data, 0) != -1
}


=== pkg/output/output_test.go ===
// Package output_test contains unit tests for the output package.
package output

import (
	"os"
	"path/filepath"
	"testing"

	"github.com/vytautas-bunevicius/repo-to-txt/pkg/config"
)

// TestWriteRepoContentsToFile verifies that the WriteRepoContentsToFile function
// successfully writes repository contents to an output file based on the configuration.
func TestWriteRepoContentsToFile(t *testing.T) {
	tempDir := t.TempDir()
	outputFile := filepath.Join(tempDir, "output.txt")

	// Create a dummy file in tempDir
	dummyFile := filepath.Join(tempDir, "test.go")
	err := os.WriteFile(dummyFile, []byte("package main\n"), 0644)
	if err != nil {
		t.Fatalf("Failed to write dummy file: %v", err)
	}

	cfg := &config.Config{
		ExcludeFolders: []string{},
		IncludeExt:     []string{".go"},
	}

	err = WriteRepoContentsToFile(tempDir, outputFile, cfg)
	if err != nil {
		t.Fatalf("WriteRepoContentsToFile returned an error: %v", err)
	}

	// Verify output file exists
	if _, err := os.Stat(outputFile); os.IsNotExist(err) {
		t.Errorf("Output file %q does not exist", outputFile)
	}

	// Verify content
	content, err := os.ReadFile(outputFile)
	if err != nil {
		t.Fatalf("Failed to read output file: %v", err)
	}

	expectedContent := "=== test.go ===\npackage main\n\n\n"
	if string(content) != expectedContent {
		t.Errorf("Output file content mismatch.\nExpected:\n%s\nGot:\n%s", expectedContent, string(content))
	}
}

// TestWriteRepoContentsToFileExclusions verifies that files and folders specified in the
// exclusion list are correctly excluded from the output file.
func TestWriteRepoContentsToFileExclusions(t *testing.T) {
	tempDir := t.TempDir()
	outputFile := filepath.Join(tempDir, "output.txt")

	// Create directories and files
	excludedDir := filepath.Join(tempDir, "docs")
	err := os.Mkdir(excludedDir, 0755)
	if err != nil {
		t.Fatalf("Failed to create excluded directory: %v", err)
	}

	excludedFile := filepath.Join(excludedDir, "README.md")
	err = os.WriteFile(excludedFile, []byte("# README"), 0644)
	if err != nil {
		t.Fatalf("Failed to write excluded file: %v", err)
	}

	includedFile := filepath.Join(tempDir, "main.go")
	err = os.WriteFile(includedFile, []byte("package main\n"), 0644)
	if err != nil {
		t.Fatalf("Failed to write included file: %v", err)
	}

	cfg := &config.Config{
		ExcludeFolders: []string{"docs"},
		IncludeExt:     []string{".go", ".md"},
	}

	err = WriteRepoContentsToFile(tempDir, outputFile, cfg)
	if err != nil {
		t.Fatalf("WriteRepoContentsToFile returned an error: %v", err)
	}

	// Verify output file exists
	if _, err := os.Stat(outputFile); os.IsNotExist(err) {
		t.Errorf("Output file %q does not exist", outputFile)
	}

	// Verify content
	content, err := os.ReadFile(outputFile)
	if err != nil {
		t.Fatalf("Failed to read output file: %v", err)
	}

	expectedContent := "=== main.go ===\npackage main\n\n\n"
	if string(content) != expectedContent {
		t.Errorf("Output file content mismatch.\nExpected:\n%s\nGot:\n%s", expectedContent, string(content))
	}
}

// TestWriteRepoContentsToFileBinaryFile verifies that binary files are skipped.
func TestWriteRepoContentsToFileBinaryFile(t *testing.T) {
	tempDir := t.TempDir()
	outputFile := filepath.Join(tempDir, "output.txt")

	// Create a binary file
	binaryFile := filepath.Join(tempDir, "image.png")
	err := os.WriteFile(binaryFile, []byte{0x89, 0x50, 0x4E, 0x47}, 0644) // PNG header bytes
	if err != nil {
		t.Fatalf("Failed to write binary file: %v", err)
	}

	// Create a text file
	textFile := filepath.Join(tempDir, "main.go")
	err = os.WriteFile(textFile, []byte("package main\n"), 0644)
	if err != nil {
		t.Fatalf("Failed to write text file: %v", err)
	}

	cfg := &config.Config{
		ExcludeFolders: []string{},
		IncludeExt:     []string{".go", ".png"},
	}

	err = WriteRepoContentsToFile(tempDir, outputFile, cfg)
	if err != nil {
		t.Fatalf("WriteRepoContentsToFile returned an error: %v", err)
	}

	// Verify output file exists
	if _, err := os.Stat(outputFile); os.IsNotExist(err) {
		t.Errorf("Output file %q does not exist", outputFile)
	}

	// Verify content contains only the text file
	content, err := os.ReadFile(outputFile)
	if err != nil {
		t.Fatalf("Failed to read output file: %v", err)
	}

	expectedContent := "=== main.go ===\npackage main\n\n\n"
	if string(content) != expectedContent {
		t.Errorf("Output file content mismatch.\nExpected:\n%s\nGot:\n%s", expectedContent, string(content))
	}
}

// TestWriteRepoContentsToFileDefaultExclusions verifies that default excluded extensions are respected.
func TestWriteRepoContentsToFileDefaultExclusions(t *testing.T) {
	tempDir := t.TempDir()
	outputFile := filepath.Join(tempDir, "output.txt")

	// Create a default excluded file
	excludedFile := filepath.Join(tempDir, "notebook.ipynb")
	err := os.WriteFile(excludedFile, []byte("{ \"cells\": [] }"), 0644)
	if err != nil {
		t.Fatalf("Failed to write excluded file: %v", err)
	}

	// Create an included file
	includedFile := filepath.Join(tempDir, "main.go")
	err = os.WriteFile(includedFile, []byte("package main\n"), 0644)
	if err != nil {
		t.Fatalf("Failed to write included file: %v", err)
	}

	cfg := &config.Config{
		ExcludeFolders: []string{},
		IncludeExt:     nil, // No specific extensions to include
	}

	err = WriteRepoContentsToFile(tempDir, outputFile, cfg)
	if err != nil {
		t.Fatalf("WriteRepoContentsToFile returned an error: %v", err)
	}

	// Verify output file exists
	if _, err := os.Stat(outputFile); os.IsNotExist(err) {
		t.Errorf("Output file %q does not exist", outputFile)
	}

	// Verify content contains only the included file
	content, err := os.ReadFile(outputFile)
	if err != nil {
		t.Fatalf("Failed to read output file: %v", err)
	}

	expectedContent := "=== main.go ===\npackage main\n\n\n"
	if string(content) != expectedContent {
		t.Errorf("Output file content mismatch.\nExpected:\n%s\nGot:\n%s", expectedContent, string(content))
	}
}


=== pkg/prompt/prompt.go ===
// Package prompt manages interactive user prompts for missing configuration inputs.
// It utilizes the huh library to create forms for collecting user input when
// necessary configuration details are not provided via command-line flags.
package prompt

import (
	"errors"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"runtime"
	"strings"

	"github.com/charmbracelet/huh"
	"github.com/vytautas-bunevicius/repo-to-txt/pkg/config"
	"github.com/vytautas-bunevicius/repo-to-txt/pkg/util"
)

// ErrEmptyInput is returned when the user provides an empty input for a required field.
var ErrEmptyInput = errors.New("input cannot be empty")

// PromptForMissingInputs prompts the user interactively for any missing configuration inputs.
// It updates the provided Config struct with the collected inputs.
//
// Parameters:
//   - cfg: A pointer to the Config struct to be populated.
//
// Returns:
//   - error: An error if prompting fails or input validation fails.
func PromptForMissingInputs(cfg *config.Config) error {
	// Prompt for repository URL if not provided
	if cfg.RepoURL == "" {
		repoForm := huh.NewForm(
			huh.NewGroup(
				huh.NewInput().
					Title("GitHub repository URL (HTTPS or SSH)").
					Value(&cfg.RepoURL).
					Validate(validateRepoURL),
			),
		)
		err := repoForm.Run()
		if err != nil {
			return fmt.Errorf("repository URL input error: %w", err)
		}
	}

	// Prompt for authentication method if not set via flag
	if !cfg.AuthFlagSet {
		var authOptions []huh.Option[config.AuthMethod]
		if isHTTPSURL(cfg.RepoURL) {
			authOptions = []huh.Option[config.AuthMethod]{
				huh.NewOption("No Authentication", config.AuthMethodNone),
				huh.NewOption("HTTPS with PAT", config.AuthMethodHTTPS),
			}
		} else if isSSHURL(cfg.RepoURL) {
			authOptions = []huh.Option[config.AuthMethod]{
				huh.NewOption("SSH Authentication", config.AuthMethodSSH),
			}
		} else {
			return errors.New("unsupported repository URL format for authentication options")
		}

		authForm := huh.NewForm(
			huh.NewGroup(
				huh.NewSelect[config.AuthMethod]().
					Title("Select authentication method").
					Options(authOptions...).
					Value(&cfg.AuthMethod),
			),
		)
		err := authForm.Run()
		if err != nil {
			return fmt.Errorf("authentication method input error: %w", err)
		}
	}

	// Prompt for additional authentication details based on the selected method
	switch cfg.AuthMethod {
	case config.AuthMethodHTTPS:
		if cfg.Username == "" || cfg.PersonalAccessToken == "" {
			httpsForm := huh.NewForm(
				huh.NewGroup(
					huh.NewInput().
						Title("GitHub username").
						Value(&cfg.Username).
						Validate(nonEmptyValidator("GitHub username")),
					huh.NewInput().
						Title("GitHub Personal Access Token").
						Value(&cfg.PersonalAccessToken).
						Password(true).
						Validate(nonEmptyValidator("Personal Access Token")),
				),
			)
			err := httpsForm.Run()
			if err != nil {
				return fmt.Errorf("HTTPS authentication input error: %w", err)
			}
		}
	case config.AuthMethodSSH:
		if cfg.SSHKeyPath == "" {
			defaultSSHKey := DefaultSSHKeyPath() // Corrected to use separate function
			sshForm := huh.NewForm(
				huh.NewGroup(
					huh.NewInput().
						Title("Path to SSH private key").
						Value(&cfg.SSHKeyPath).
						Placeholder(defaultSSHKey).
						Validate(func(s string) error {
							if s == "" {
								cfg.SSHKeyPath = defaultSSHKey
								return nil
							}
							if _, err := os.Stat(s); os.IsNotExist(err) {
								return fmt.Errorf("SSH key file does not exist at path: %s", s)
							}
							return nil
						}),
				),
			)
			err := sshForm.Run()
			if err != nil {
				return fmt.Errorf("SSH key path input error: %w", err)
			}
		}

		if isSSHKeyPassphraseProtected(cfg.SSHKeyPath) && cfg.SSHPassphrase == "" {
			passphraseForm := huh.NewForm(
				huh.NewGroup(
					huh.NewInput().
						Title("SSH key passphrase (leave empty if none)").
						Value(&cfg.SSHPassphrase).
						Password(true),
				),
			)
			err := passphraseForm.Run()
			if err != nil {
				return fmt.Errorf("SSH passphrase input error: %w", err)
			}
		}
	}

	// Prompt for output configuration if not provided
	if cfg.OutputDir == "" {
		var excludeFolders, includeExt string
		defaultOutputDir := defaultDownloadsPath() // Corrected to use separate function
		outputForm := huh.NewForm(
			huh.NewGroup(
				huh.NewInput().
					Title("Output directory").
					Value(&cfg.OutputDir).
					Placeholder(defaultOutputDir).
					Validate(func(s string) error {
						if s == "" {
							cfg.OutputDir = defaultOutputDir
							return nil
						}
						return nil // Allow user to specify a custom path without validation
					}),
				huh.NewInput().
					Title("Folders to exclude (comma-separated, leave empty to include all)").
					Value(&excludeFolders),
				huh.NewInput().
					Title("File extensions to include (comma-separated, leave empty to include all)").
					Value(&includeExt),
			),
		)
		err := outputForm.Run()
		if err != nil {
			return fmt.Errorf("output configuration input error: %w", err)
		}

		cfg.ExcludeFolders = util.ParseCommaSeparated(excludeFolders)
		cfg.IncludeExt = util.ParseCommaSeparated(includeExt)
	}

	// Prompt for exact file names to copy if not provided
	if len(cfg.FileNames) == 0 {
		var filesInput string
		filesForm := huh.NewForm(
			huh.NewGroup(
				huh.NewInput().
					Title("Exact file names to copy (comma-separated, leave empty to copy all files)").
					Value(&filesInput).
					// Replace Validate(nil) with a no-op validator
					Validate(func(s string) error { return nil }),
			),
		)
		err := filesForm.Run()
		if err != nil {
			return fmt.Errorf("file names input error: %w", err)
		}
		cfg.FileNames = util.ParseCommaSeparated(filesInput)
	}

	// Prompt for copy to clipboard if not set
	if !cfg.CopyToClipboardSet {
		clipboardForm := huh.NewForm(
			huh.NewGroup(
				huh.NewConfirm().
					Title("Copy output to clipboard?").
					Value(&cfg.CopyToClipboard),
			),
		)
		err := clipboardForm.Run()
		if err != nil {
			return fmt.Errorf("clipboard option input error: %w", err)
		}
	}

	// Ensure the output directory exists
	if err := os.MkdirAll(cfg.OutputDir, os.ModePerm); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	return nil
}

// SelectFile prompts the user to select a file from multiple matches for a given file name.
//
// Parameters:
//   - fileName: The name of the file to select.
//   - matches: A slice of file paths that match the file name.
//
// Returns:
//   - string: The selected file path.
//   - error: An error if the selection fails.
func SelectFile(fileName string, matches []string) (string, error) {
	fmt.Printf("Multiple matches found for file '%s':\n", fileName)
	for i, match := range matches {
		fmt.Printf("  %d) %s\n", i+1, match)
	}
	fmt.Printf("Select the number of the file you want to include (1-%d): ", len(matches))

	var choice int
	_, err := fmt.Scanf("%d\n", &choice)
	if err != nil {
		return "", fmt.Errorf("invalid input: %w", err)
	}

	if choice < 1 || choice > len(matches) {
		return "", errors.New("choice out of range")
	}

	return matches[choice-1], nil
}

// validateRepoURL validates the format of the provided GitHub repository URL.
// It ensures that the URL is either a valid HTTPS or SSH GitHub repository URL.
//
// Parameters:
//   - repoURL: The repository URL to validate.
//
// Returns:
//   - error: An error if the URL is invalid, nil otherwise.
func validateRepoURL(repoURL string) error {
	if strings.TrimSpace(repoURL) == "" {
		return errors.New("repository URL cannot be empty")
	}

	if isHTTPSURL(repoURL) || isSSHURL(repoURL) {
		return nil
	}

	return errors.New("URL must be either HTTPS (https://github.com/user/repo) or SSH (git@github.com:user/repo) format")
}

// isHTTPSURL checks if the provided URL is an HTTPS GitHub repository URL.
//
// Parameters:
//   - url: The repository URL to check.
//
// Returns:
//   - bool: True if the URL starts with "https://github.com/", false otherwise.
func isHTTPSURL(url string) bool {
	return strings.HasPrefix(url, "https://github.com/")
}

// isSSHURL checks if the provided URL is an SSH GitHub repository URL.
//
// Parameters:
//   - url: The repository URL to check.
//
// Returns:
//   - bool: True if the URL starts with "git@github.com:", false otherwise.
func isSSHURL(url string) bool {
	return strings.HasPrefix(url, "git@github.com:")
}

// nonEmptyValidator returns a validator function that ensures the input string is not empty.
//
// Parameters:
//   - fieldName: The name of the field being validated.
//
// Returns:
//   - func(string) error: A validator function that returns an error if the input is empty.
func nonEmptyValidator(fieldName string) func(string) error {
	return func(s string) error {
		if strings.TrimSpace(s) == "" {
			return fmt.Errorf("%s cannot be empty", fieldName)
		}
		return nil
	}
}

// defaultDownloadsPath intelligently detects the Downloads directory across different OSes.
func defaultDownloadsPath() string {
	home, err := os.UserHomeDir()
	if err != nil {
		return "."
	}

	var downloads string

	switch runtime.GOOS {
	case "windows":
		downloads = filepath.Join(home, "Downloads")
	case "darwin", "linux":
		xdgDownloads := os.Getenv("XDG_DOWNLOAD_DIR")
		if xdgDownloads != "" && xdgDownloads != "$HOME/Downloads" {
			downloads = xdgDownloads
		} else {
			downloads = filepath.Join(home, "Downloads")
		}
	default:
		downloads = filepath.Join(home, "Downloads")
	}

	// Check if downloads directory exists, else fallback to home
	if _, err := os.Stat(downloads); os.IsNotExist(err) {
		downloads = home
	}

	return downloads
}

// DefaultSSHKeyPath returns the default SSH key path (e.g., ~/.ssh/id_rsa).
func DefaultSSHKeyPath() string {
	home, err := os.UserHomeDir()
	if err != nil {
		return ""
	}

	return filepath.Join(home, ".ssh", "id_rsa")
}

// isSSHKeyPassphraseProtected checks if the SSH key at the given path is protected by a passphrase.
// It does this by looking for the "ENCRYPTED" keyword in the key file.
//
// Parameters:
//   - keyPath: The file system path to the SSH private key.
//
// Returns:
//   - bool: True if the key is passphrase protected, false otherwise.
func isSSHKeyPassphraseProtected(keyPath string) bool {
	file, err := os.Open(keyPath)
	if err != nil {
		return false
	}
	defer file.Close()

	// Attempt to read the first few bytes to check for encryption.
	buf := make([]byte, 100)
	n, err := file.Read(buf)
	if err != nil && err != io.EOF {
		return false
	}

	content := string(buf[:n])
	return strings.Contains(content, "ENCRYPTED")
}


=== pkg/prompt/prompt_test.go ===
// Package prompt_test contains unit tests for the prompt package.
package prompt

import (
	"os"
	"path/filepath"
	"testing"

	"github.com/vytautas-bunevicius/repo-to-txt/pkg/config"
)

// TestValidateRepoURL verifies that the validateRepoURL function correctly validates
// various repository URL formats.
func TestValidateRepoURL(t *testing.T) {
	tests := []struct {
		name    string
		url     string
		wantErr bool
	}{
		{"Valid HTTPS URL", "https://github.com/user/repo.git", false},
		{"Valid SSH URL", "git@github.com:user/repo.git", false},
		{"Invalid HTTP URL", "http://github.com/user/repo.git", false}, // Allowed as per isHTTPSURL and isSSHURL
		{"Invalid FTP URL", "ftp://github.com/user/repo.git", true},
		{"Empty URL", "", true},
		{"HTTPS without .git", "https://github.com/user/repo", false},
		{"SSH without .git", "git@github.com:user/repo", false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := validateRepoURL(tt.url)
			if (err != nil) != tt.wantErr {
				t.Errorf("validateRepoURL(%q) error = %v, wantErr %v", tt.url, err, tt.wantErr)
			}
		})
	}
}

// TestIsSSHKeyPassphraseProtected verifies that the isSSHKeyPassphraseProtected function
// correctly identifies whether an SSH key is passphrase protected.
func TestIsSSHKeyPassphraseProtected(t *testing.T) {
	// Create a temporary file for testing
	tmpfile, err := os.CreateTemp("", "test-ssh-key")
	if err != nil {
		t.Fatal(err)
	}
	defer os.Remove(tmpfile.Name())

	// Test with non-encrypted content
	if _, err := tmpfile.Write([]byte("-----BEGIN OPENSSH PRIVATE KEY-----\n")); err != nil {
		t.Fatal(err)
	}
	if isSSHKeyPassphraseProtected(tmpfile.Name()) {
		t.Error("Expected non-encrypted key to return false")
	}

	// Test with encrypted content
	if err := tmpfile.Truncate(0); err != nil {
		t.Fatal(err)
	}
	if _, err := tmpfile.Seek(0, 0); err != nil {
		t.Fatal(err)
	}
	if _, err := tmpfile.Write([]byte("-----BEGIN OPENSSH PRIVATE KEY-----\nENCRYPTED\n")); err != nil {
		t.Fatal(err)
	}
	if !isSSHKeyPassphraseProtected(tmpfile.Name()) {
		t.Error("Expected encrypted key to return true")
	}
}

// TestDefaultSSHKeyPath verifies that the DefaultSSHKeyPath function returns the correct default SSH key path.
func TestDefaultSSHKeyPath(t *testing.T) {
	home, err := os.UserHomeDir()
	if err != nil {
		t.Fatal(err)
	}
	expected := filepath.Join(home, ".ssh", "id_rsa")
	if got := DefaultSSHKeyPath(); got != expected {
		t.Errorf("defaultSSHKeyPath() = %v, want %v", got, expected)
	}
}

// TestDefaultDownloadsPath verifies that the defaultDownloadsPath function returns the correct default Downloads path.
func TestDefaultDownloadsPath(t *testing.T) {
	home, err := os.UserHomeDir()
	if err != nil {
		t.Fatal(err)
	}
	expected := filepath.Join(home, "Downloads")
	if got := defaultDownloadsPath(); got != expected {
		t.Errorf("defaultDownloadsPath() = %v, want %v", got, expected)
	}
}

// TestPromptForMissingInputs is a placeholder for testing the PromptForMissingInputs function.
// In a real scenario, you would mock the huh library to simulate user input.
func TestPromptForMissingInputs(t *testing.T) {
	// This is a basic test structure. In a real scenario, you'd need to mock the huh library,
	// which is beyond the scope of this example. Here's a simplified version:
	cfg := &config.Config{}
	err := PromptForMissingInputs(cfg)
	if err != nil {
		t.Fatalf("PromptForMissingInputs() error = %v", err)
	}
}


=== pkg/util/util.go ===
// === pkg/util/util.go ===
// Package util provides utility functions used across the repo-to-txt tool.
// These functions include string manipulation and slice operations.
package util

import (
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
)

// Contains checks if a slice contains a particular string (case-insensitive).
//
// Parameters:
//   - slice: The slice of strings to search within.
//   - item: The string to search for.
//
// Returns:
//   - bool: True if the slice contains the item, false otherwise.
func Contains(slice []string, item string) bool {
	for _, s := range slice {
		if strings.EqualFold(s, item) {
			return true
		}
	}
	return false
}

// ParseCommaSeparated splits a comma-separated string into a slice of trimmed strings.
//
// Parameters:
//   - input: The comma-separated string.
//
// Returns:
//   - []string: A slice of trimmed strings. Returns nil if the input is empty.
func ParseCommaSeparated(input string) []string {
	if input == "" {
		return nil
	}
	parts := strings.Split(input, ",")
	result := make([]string, 0, len(parts))
	for _, part := range parts {
		if trimmed := strings.TrimSpace(part); trimmed != "" {
			result = append(result, trimmed)
		}
	}
	return result
}

// CopyFile copies a file from src to dst. If dst does not exist, it is created.
// If dst exists, it is overwritten.
//
// Parameters:
//   - src: Source file path.
//   - dst: Destination file path.
//
// Returns:
//   - error: An error if the copy fails.
func CopyFile(src, dst string) error {
	sourceFileStat, err := os.Stat(src)
	if err != nil {
		return fmt.Errorf("unable to stat source file: %w", err)
	}

	if !sourceFileStat.Mode().IsRegular() {
		return fmt.Errorf("source file %s is not a regular file", src)
	}

	source, err := os.Open(src)
	if err != nil {
		return fmt.Errorf("unable to open source file: %w", err)
	}
	defer source.Close()

	// Ensure the destination directory exists
	destDir := filepath.Dir(dst)
	if err := os.MkdirAll(destDir, os.ModePerm); err != nil {
		return fmt.Errorf("unable to create destination directory: %w", err)
	}

	destination, err := os.Create(dst)
	if err != nil {
		return fmt.Errorf("unable to create destination file: %w", err)
	}
	defer destination.Close()

	_, err = io.Copy(destination, source)
	if err != nil {
		return fmt.Errorf("error copying data: %w", err)
	}

	return nil
}


=== pkg/util/util_test.go ===
// Package util_test contains unit tests for the util package.
package util

import "testing"

// TestParseCommaSeparated verifies that the ParseCommaSeparated function correctly
// splits and trims comma-separated strings into a slice.
func TestParseCommaSeparated(t *testing.T) {
	tests := []struct {
		input    string
		expected []string
	}{
		{"a, b , c", []string{"a", "b", "c"}},
		{"  foo,bar , baz ", []string{"foo", "bar", "baz"}},
		{"", nil},
		{", ,", nil},
		{"single", []string{"single"}},
	}

	for _, tt := range tests {
		t.Run(tt.input, func(t *testing.T) {
			result := ParseCommaSeparated(tt.input)
			if len(result) != len(tt.expected) {
				t.Fatalf("Expected %d items, got %d", len(tt.expected), len(result))
			}
			for i, v := range tt.expected {
				if result[i] != v {
					t.Errorf("Expected %q at index %d, got %q", v, i, result[i])
				}
			}
		})
	}
}

// TestContains verifies that the Contains function correctly identifies
// the presence or absence of items in a slice.
func TestContains(t *testing.T) {
	tests := []struct {
		slice    []string
		item     string
		expected bool
	}{
		{[]string{"Go", "Python", "Java"}, "python", true},
		{[]string{"Go", "Python", "Java"}, "C++", false},
		{[]string{}, "any", false},
		{[]string{"Test"}, "test", true},
		{[]string{"CASE"}, "case", true},
		{[]string{"MixEd", "CaSe"}, "mIxEd", true},
	}

	for _, tt := range tests {
		t.Run(tt.item, func(t *testing.T) {
			result := Contains(tt.slice, tt.item)
			if result != tt.expected {
				t.Errorf("Contains(%v, %q) = %v; want %v", tt.slice, tt.item, result, tt.expected)
			}
		})
	}
}


=== repo-to-txt.txt ===
=== pkg/prompt/prompt.go ===
// === pkg/prompt/prompt.go ===
// Package prompt manages interactive user prompts for missing configuration inputs.
// It utilizes the huh library to create forms for collecting user input when
// necessary configuration details are not provided via command-line flags.
package prompt

import (
	"errors"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"runtime"
	"strings"

	"github.com/charmbracelet/huh"
	"github.com/vytautas-bunevicius/repo-to-txt/pkg/config"
	"github.com/vytautas-bunevicius/repo-to-txt/pkg/util"
)

// ErrEmptyInput is returned when the user provides an empty input for a required field.
var ErrEmptyInput = errors.New("input cannot be empty")

// PromptForMissingInputs prompts the user interactively for any missing configuration inputs.
// It updates the provided Config struct with the collected inputs.
//
// Parameters:
//   - cfg: A pointer to the Config struct to be populated.
//
// Returns:
//   - error: An error if prompting fails or input validation fails.
func PromptForMissingInputs(cfg *config.Config) error {
	// Prompt for repository URL if not provided
	if cfg.RepoURL == "" {
		repoForm := huh.NewForm(
			huh.NewGroup(
				huh.NewInput().
					Title("GitHub repository URL (HTTPS or SSH)").
					Value(&cfg.RepoURL).
					Validate(validateRepoURL),
			),
		)
		err := repoForm.Run()
		if err != nil {
			return fmt.Errorf("repository URL input error: %w", err)
		}
	}

	// Prompt for authentication method if not set via flag
	if !cfg.AuthFlagSet {
		var authOptions []huh.Option[config.AuthMethod]
		if isHTTPSURL(cfg.RepoURL) {
			authOptions = []huh.Option[config.AuthMethod]{
				huh.NewOption("No Authentication", config.AuthMethodNone),
				huh.NewOption("HTTPS with PAT", config.AuthMethodHTTPS),
			}
		} else if isSSHURL(cfg.RepoURL) {
			authOptions = []huh.Option[config.AuthMethod]{
				huh.NewOption("SSH Authentication", config.AuthMethodSSH),
			}
		} else {
			return errors.New("unsupported repository URL format for authentication options")
		}

		authForm := huh.NewForm(
			huh.NewGroup(
				huh.NewSelect[config.AuthMethod]().
					Title("Select authentication method").
					Options(authOptions...).
					Value(&cfg.AuthMethod),
			),
		)
		err := authForm.Run()
		if err != nil {
			return fmt.Errorf("authentication method input error: %w", err)
		}
	}

	// Prompt for additional authentication details based on the selected method
	switch cfg.AuthMethod {
	case config.AuthMethodHTTPS:
		if cfg.Username == "" || cfg.PersonalAccessToken == "" {
			httpsForm := huh.NewForm(
				huh.NewGroup(
					huh.NewInput().
						Title("GitHub username").
						Value(&cfg.Username).
						Validate(nonEmptyValidator("GitHub username")),
					huh.NewInput().
						Title("GitHub Personal Access Token").
						Value(&cfg.PersonalAccessToken).
						Password(true).
						Validate(nonEmptyValidator("Personal Access Token")),
				),
			)
			err := httpsForm.Run()
			if err != nil {
				return fmt.Errorf("HTTPS authentication input error: %w", err)
			}
		}
	case config.AuthMethodSSH:
		if cfg.SSHKeyPath == "" {
			defaultSSHKey := DefaultSSHKeyPath() // Corrected to use separate function
			sshForm := huh.NewForm(
				huh.NewGroup(
					huh.NewInput().
						Title("Path to SSH private key").
						Value(&cfg.SSHKeyPath).
						Placeholder(defaultSSHKey).
						Validate(func(s string) error {
							if s == "" {
								cfg.SSHKeyPath = defaultSSHKey
								return nil
							}
							if _, err := os.Stat(s); os.IsNotExist(err) {
								return fmt.Errorf("SSH key file does not exist at path: %s", s)
							}
							return nil
						}),
				),
			)
			err := sshForm.Run()
			if err != nil {
				return fmt.Errorf("SSH key path input error: %w", err)
			}
		}

		if isSSHKeyPassphraseProtected(cfg.SSHKeyPath) && cfg.SSHPassphrase == "" {
			passphraseForm := huh.NewForm(
				huh.NewGroup(
					huh.NewInput().
						Title("SSH key passphrase (leave empty if none)").
						Value(&cfg.SSHPassphrase).
						Password(true),
				),
			)
			err := passphraseForm.Run()
			if err != nil {
				return fmt.Errorf("SSH passphrase input error: %w", err)
			}
		}
	}

	// Prompt for output configuration if not provided
	if cfg.OutputDir == "" {
		var excludeFolders, includeExt string
		defaultOutputDir := defaultDownloadsPath() // Corrected to use separate function
		outputForm := huh.NewForm(
			huh.NewGroup(
				huh.NewInput().
					Title("Output directory").
					Value(&cfg.OutputDir).
					Placeholder(defaultOutputDir).
					Validate(func(s string) error {
						if s == "" {
							cfg.OutputDir = defaultOutputDir
							return nil
						}
						return nil // Allow user to specify a custom path without validation
					}),
				huh.NewInput().
					Title("Folders to exclude (comma-separated, leave empty to include all)").
					Value(&excludeFolders),
				huh.NewInput().
					Title("File extensions to include (comma-separated, leave empty to include all)").
					Value(&includeExt),
			),
		)
		err := outputForm.Run()
		if err != nil {
			return fmt.Errorf("output configuration input error: %w", err)
		}

		cfg.ExcludeFolders = util.ParseCommaSeparated(excludeFolders)
		cfg.IncludeExt = util.ParseCommaSeparated(includeExt)
	}

	// Prompt for exact file names to copy if not provided
	if len(cfg.FileNames) == 0 {
		var filesInput string
		filesForm := huh.NewForm(
			huh.NewGroup(
				huh.NewInput().
					Title("Exact file names to copy (comma-separated, leave empty to copy all files)").
					Value(&filesInput).
					// Replace Validate(nil) with a no-op validator
					Validate(func(s string) error { return nil }),
			),
		)
		err := filesForm.Run()
		if err != nil {
			return fmt.Errorf("file names input error: %w", err)
		}
		cfg.FileNames = util.ParseCommaSeparated(filesInput)
	}

	// Prompt for copy to clipboard if not set
	if !cfg.CopyToClipboardSet {
		clipboardForm := huh.NewForm(
			huh.NewGroup(
				huh.NewConfirm().
					Title("Copy output to clipboard?").
					Value(&cfg.CopyToClipboard),
			),
		)
		err := clipboardForm.Run()
		if err != nil {
			return fmt.Errorf("clipboard option input error: %w", err)
		}
	}

	// Ensure the output directory exists
	if err := os.MkdirAll(cfg.OutputDir, os.ModePerm); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	return nil
}

// SelectFile prompts the user to select a file from multiple matches for a given file name.
//
// Parameters:
//   - fileName: The name of the file to select.
//   - matches: A slice of file paths that match the file name.
//
// Returns:
//   - string: The selected file path.
//   - error: An error if the selection fails.
func SelectFile(fileName string, matches []string) (string, error) {
	fmt.Printf("Multiple matches found for file '%s':\n", fileName)
	for i, match := range matches {
		fmt.Printf("  %d) %s\n", i+1, match)
	}
	fmt.Printf("Select the number of the file you want to include (1-%d): ", len(matches))

	var choice int
	_, err := fmt.Scanf("%d\n", &choice)
	if err != nil {
		return "", fmt.Errorf("invalid input: %w", err)
	}

	if choice < 1 || choice > len(matches) {
		return "", errors.New("choice out of range")
	}

	return matches[choice-1], nil
}

// validateRepoURL validates the format of the provided GitHub repository URL.
// It ensures that the URL is either a valid HTTPS or SSH GitHub repository URL.
//
// Parameters:
//   - repoURL: The repository URL to validate.
//
// Returns:
//   - error: An error if the URL is invalid, nil otherwise.
func validateRepoURL(repoURL string) error {
	if strings.TrimSpace(repoURL) == "" {
		return errors.New("repository URL cannot be empty")
	}

	if isHTTPSURL(repoURL) || isSSHURL(repoURL) {
		return nil
	}

	return errors.New("URL must be either HTTPS (https://github.com/user/repo) or SSH (git@github.com:user/repo) format")
}

// isHTTPSURL checks if the provided URL is an HTTPS GitHub repository URL.
//
// Parameters:
//   - url: The repository URL to check.
//
// Returns:
//   - bool: True if the URL starts with "https://github.com/", false otherwise.
func isHTTPSURL(url string) bool {
	return strings.HasPrefix(url, "https://github.com/")
}

// isSSHURL checks if the provided URL is an SSH GitHub repository URL.
//
// Parameters:
//   - url: The repository URL to check.
//
// Returns:
//   - bool: True if the URL starts with "git@github.com:", false otherwise.
func isSSHURL(url string) bool {
	return strings.HasPrefix(url, "git@github.com:")
}

// nonEmptyValidator returns a validator function that ensures the input string is not empty.
//
// Parameters:
//   - fieldName: The name of the field being validated.
//
// Returns:
//   - func(string) error: A validator function that returns an error if the input is empty.
func nonEmptyValidator(fieldName string) func(string) error {
	return func(s string) error {
		if strings.TrimSpace(s) == "" {
			return fmt.Errorf("%s cannot be empty", fieldName)
		}
		return nil
	}
}

// defaultDownloadsPath intelligently detects the Downloads directory across different OSes.
func defaultDownloadsPath() string {
	home, err := os.UserHomeDir()
	if err != nil {
		return "."
	}

	var downloads string

	switch runtime.GOOS {
	case "windows":
		downloads = filepath.Join(home, "Downloads")
	case "darwin", "linux":
		xdgDownloads := os.Getenv("XDG_DOWNLOAD_DIR")
		if xdgDownloads != "" && xdgDownloads != "$HOME/Downloads" {
			downloads = xdgDownloads
		} else {
			downloads = filepath.Join(home, "Downloads")
		}
	default:
		downloads = filepath.Join(home, "Downloads")
	}

	// Check if downloads directory exists, else fallback to home
	if _, err := os.Stat(downloads); os.IsNotExist(err) {
		downloads = home
	}

	return downloads
}

// DefaultSSHKeyPath returns the default SSH key path (e.g., ~/.ssh/id_rsa).
func DefaultSSHKeyPath() string {
	home, err := os.UserHomeDir()
	if err != nil {
		return ""
	}

	return filepath.Join(home, ".ssh", "id_rsa")
}

// isSSHKeyPassphraseProtected checks if the SSH key at the given path is protected by a passphrase.
// It does this by looking for the "ENCRYPTED" keyword in the key file.
//
// Parameters:
//   - keyPath: The file system path to the SSH private key.
//
// Returns:
//   - bool: True if the key is passphrase protected, false otherwise.
func isSSHKeyPassphraseProtected(keyPath string) bool {
	file, err := os.Open(keyPath)
	if err != nil {
		return false
	}
	defer file.Close()

	// Attempt to read the first few bytes to check for encryption.
	buf := make([]byte, 100)
	n, err := file.Read(buf)
	if err != nil && err != io.EOF {
		return false
	}

	content := string(buf[:n])
	return strings.Contains(content, "ENCRYPTED")
}




=== retail-bank-risk-evaluation.txt ===
=== setup.py ===
import pathlib
from setuptools import setup, find_packages

HERE = pathlib.Path(__file__).parent
README = (HERE / "README.md").read_text()
REQUIREMENTS = (HERE / "requirements.txt").read_text().splitlines()

setup(
    name="retail_bank_risk",
    version="0.1",
    packages=find_packages(where="src"),
    package_dir={"": "src"},
    install_requires=REQUIREMENTS,
    description="Retail Bank Risk Evaluation",
    long_description=README,
    long_description_content_type="text/markdown",
)


=== src/retail_bank_risk/__init__.py ===


=== src/retail_bank_risk/advanced_visualizations_utils.py ===
# cspell:disable
# pylint: disable=line-too-long

"""
This module contains a collection of functions for visualizing and analyzing machine learning model performance,
including SHAP values, model comparison metrics, and confusion matrices.

The visualizations are created using Plotly and are designed to be informative, aesthetically pleasing,
and easily interpretable. The module also supports saving these visualizations as images.

Key functionalities include:
- `shap_summary_plot`: Creates a bar plot to display SHAP feature importance.
- `shap_force_plot`: Generates a waterfall plot to visualize individual SHAP values and their impact on predictions.
- `plot_model_performance`: Plots and compares performance metrics across different models using a grouped bar chart.
- `plot_combined_confusion_matrices`: Creates confusion matrices for multiple models, visualizing their classification performance.

Constants defined:
- `BACKGROUND_COLOR`: The background color used for all plots.
- `PRIMARY_COLORS`: A palette of primary colors used for the main elements of the visualizations.
- `PLOT_COLORS`: A subset of colors used specifically for plotting.
- `SECONDARY_COLORS`: A palette of secondary colors for additional elements.
- `ALL_COLORS`: A combination of primary and secondary colors for use across different plots.

This module is intended for use in data analysis workflows where model interpretability and performance
visualization are essential. The plots generated can be displayed interactively or saved for reporting purposes.
"""

from typing import List, Optional, Dict, Any

import numpy as np
import pandas as pd

from sklearn.metrics import confusion_matrix, precision_recall_curve, roc_curve
from sklearn.model_selection import learning_curve

import plotly.graph_objects as go
import plotly.express as px
from plotly.subplots import make_subplots

# Constants
BACKGROUND_COLOR = "#EEECE2"
PRIMARY_COLORS = ["#CC7B5C", "#D4A27F", "#EBDBBC", "#9C8AA5"]
PLOT_COLORS = ["#91A694", "#9C8AA5", "#CC7B5C"]
SECONDARY_COLORS = [
    "#91A694",
    "#8B9BAE",
    "#666663",
    "#BFBFBA",
    "#E5E4DF",
    "#F0F0EB",
    "#FAFAF7",
]
ALL_COLORS = PRIMARY_COLORS + SECONDARY_COLORS


def shap_summary_plot(
    shap_values: np.ndarray,
    feature_names: List[str],
    save_path: Optional[str] = None,
) -> None:
    """Creates a bar plot of SHAP feature importance.

    Args:
        shap_values (np.ndarray): The SHAP values for each feature.
        feature_names (List[str]): The names of the features.
        save_path (Optional[str]): The file path to save the plot image. Defaults to None.

    Returns:
        None: The function displays the plot and optionally saves it.
    """
    shap_mean = np.abs(shap_values).mean(axis=0)
    feature_importance = pd.DataFrame(
        {"feature": feature_names, "importance": shap_mean}
    )
    feature_importance = feature_importance.sort_values(
        "importance", ascending=True
    )

    fig = px.bar(
        feature_importance,
        x="importance",
        y="feature",
        orientation="h",
        title="SHAP Feature Importance",
        labels={"importance": "mean(|SHAP value|)", "feature": "Feature"},
        color="importance",
        color_continuous_scale=PRIMARY_COLORS,
    )

    fig.update_layout(
        height=1200,
        width=1200,
        plot_bgcolor=BACKGROUND_COLOR,
        paper_bgcolor=BACKGROUND_COLOR,
        font=dict(family="Styrene A", size=12, color="#191919"),
        title=dict(
            text="SHAP Feature Importance",
            x=0.5,
            xanchor="center",
            font=dict(family="Styrene B", size=20, color="#191919"),
        ),
    )

    if save_path:
        fig.write_image(save_path)


def shap_force_plot(
    shap_data: Dict[str, Any],
    explainer: Any,
    idx: int = 0,
    save_path: Optional[str] = None,
) -> None:
    """
    Generates a waterfall plot to visualize individual SHAP values and their impact on predictions.

    Args:
        shap_data (Dict[str, Any]): A dictionary containing 'shap_values', 'x_data', and 'feature_names'.
        explainer (Any): The SHAP explainer object.
        idx (int, optional): The index of the instance to plot. Defaults to 0.
        save_path (Optional[str]): The file path to save the plot as an image. Defaults to None.

    Returns:
        None: This function does not return anything. It plots the SHAP values using Plotly.
    """
    shap_values = shap_data["shap_values"]
    x_data = shap_data["x_data"]
    feature_names = shap_data["feature_names"]

    features = pd.DataFrame(
        {
            "feature": feature_names,
            "value": x_data[idx],
            "shap": shap_values[idx],
        }
    )
    features = features.sort_values("shap", key=abs, ascending=False)

    base_value = getattr(explainer, "expected_value", None)
    if base_value is None:
        raise AttributeError(
            "The explainer object does not have an 'expected_value' attribute."
        )

    fig = go.Figure(
        go.Waterfall(
            name="20",
            orientation="h",
            measure=["relative"] * len(features) + ["total"],
            x=list(features.loc[:, "shap"]) + [base_value],
            textposition="outside",
            text=[
                f"{feat}: {val:.2f}"
                for _, row in features.iterrows()
                for feat, val in zip(row["feature"], row["value"])
            ]
            + ["Base value"],
            y=list(features.loc[:, "feature"]) + ["Base value"],
            connector={"line": {"color": "#666663"}},
            decreasing={"marker": {"color": PRIMARY_COLORS[0]}},
            increasing={"marker": {"color": PRIMARY_COLORS[1]}},
        )
    )

    fig.update_layout(
        height=800,
        width=800,
        plot_bgcolor=BACKGROUND_COLOR,
        paper_bgcolor=BACKGROUND_COLOR,
        font=dict(family="Styrene A", size=12, color="#191919"),
        title=dict(font=dict(family="Styrene B", size=20, color="#191919")),
    )
    if save_path:
        fig.write_image(save_path)


def plot_model_performance(
    results: Dict[str, Dict[str, float]],
    metrics: List[str],
    save_path: Optional[str] = None,
) -> None:
    """Plots and optionally saves a bar chart of model performance metrics with legend on the right.

    Args:
        results: A dictionary with model names as keys and dicts of performance metrics as values.
        metrics: List of performance metrics to plot (e.g., 'Accuracy', 'Precision').
        save_path: Optional path to save the plot image.

    Returns:
        None. Displays the plot and optionally saves it to a file.
    """
    model_names = list(results.keys())
    data = {
        metric: [results[name][metric] for name in model_names]
        for metric in metrics
    }

    fig = go.Figure()

    for i, metric in enumerate(metrics):
        fig.add_trace(
            go.Bar(
                x=model_names,
                y=data[metric],
                name=metric,
                marker_color=ALL_COLORS[i % len(ALL_COLORS)],
                text=[f"{value:.2f}" for value in data[metric]],
                textposition="auto",
            )
        )

    axis_font = {"family": "Styrene A", "color": "#191919"}

    fig.update_layout(
        barmode="group",
        title={
            "text": "Comparison of Model Performance Metrics",
            "y": 0.95,
            "x": 0.5,
            "xanchor": "center",
            "yanchor": "top",
            "font": {"family": "Styrene B", "size": 24, "color": "#191919"},
        },
        xaxis_title="Model",
        yaxis_title="Value",
        legend_title="Metrics",
        font={**axis_font, "size": 14},
        height=500,
        width=1200,
        template="plotly_white",
        legend={"yanchor": "top", "y": 1, "xanchor": "left", "x": 1.02},
        plot_bgcolor=BACKGROUND_COLOR,
        paper_bgcolor=BACKGROUND_COLOR,
    )

    fig.update_yaxes(
        range=[0, 1], showgrid=True, gridwidth=1, gridcolor="LightGrey"
    )
    fig.update_xaxes(tickangle=-45, tickfont={**axis_font, "size": 12})

    fig.show()

    if save_path:
        fig.write_image(save_path)


def plot_combined_confusion_matrices(
    results: Dict[str, Dict[str, float]],
    y_test: np.ndarray,
    y_pred_dict: Dict[str, np.ndarray],
    labels: Optional[List[str]] = None,
    save_path: Optional[str] = None,
) -> None:
    """Plots combined confusion matrices for multiple models.

    Args:
        results (Dict[str, Dict[str, float]]): A dictionary containing the results of each model.
            The keys are the model names, and the values are dictionaries containing the model's performance metrics.
        y_test (np.ndarray): The true labels of the test data.
        y_pred_dict (Dict[str, np.ndarray]): A dictionary containing the predicted labels for each model.
            The keys are the model names, and the values are the predicted labels.
        labels (Optional[List[str]], optional): A list of labels for the classes. Defaults to None.
        save_path (Optional[str], optional): The file path to save the plot as an image. Defaults to None.

    Returns:
        None: This function does not return anything. It plots the confusion matrices using Plotly.

    Raises:
        None: This function does not raise any exceptions.

    """
    n_models = len(results)

    if n_models <= 2:
        rows, cols = 1, 2
    else:
        rows, cols = 2, 2

    fig = make_subplots(
        rows=rows,
        cols=cols,
        subplot_titles=list(results.keys()) + [""] * (rows * cols - n_models),  # type: ignore
        vertical_spacing=0.2,
        horizontal_spacing=0.1,
    )

    axis_font = {"family": "Styrene A", "color": "#191919"}

    for i, name in enumerate(results.keys()):  # type: ignore
        row = i // cols + 1
        col = i % cols + 1

        cm = confusion_matrix(y_test, y_pred_dict[name])  # type: ignore
        cm_percent = cm.astype("float") / cm.sum(axis=1)[:, np.newaxis] * 100

        text = [
            [
                f"TN: {cm[0][0]}<br>({cm_percent[0][0]:.1f}%)",
                f"FP: {cm[0][1]}<br>({cm_percent[0][1]:.1f}%)",
            ],
            [
                f"FN: {cm[1][0]}<br>({cm_percent[1][0]:.1f}%)",
                f"TP: {cm[1][1]}<br>({cm_percent[1][1]:.1f}%)",
            ],
        ]

        colorscale = [
            [0, PRIMARY_COLORS[2]],
            [0.33, PRIMARY_COLORS[1]],
            [0.66, PRIMARY_COLORS[1]],
            [1, PRIMARY_COLORS[0]],
        ]

        heatmap = go.Heatmap(
            z=cm,
            x=labels or ["No Stroke", "Stroke"],  # type: ignore
            y=labels or ["No Stroke", "Stroke"],  # type: ignore
            hoverongaps=False,
            text=text,
            texttemplate="%{text}",
            colorscale=colorscale,
            showscale=False,
        )

        fig.add_trace(heatmap, row=row, col=col)

        fig.update_xaxes(
            title_text="Predicted",
            row=row,
            col=col,
            tickfont={**axis_font, "size": 10},
            title_standoff=25,
        )
        fig.update_yaxes(
            title_text="Actual",
            row=row,
            col=col,
            tickfont={**axis_font, "size": 10},
            title_standoff=25,
        )

    # Adjust layout based on number of models
    height = 600 if n_models <= 2 else 1000
    width = 1200

    fig.update_layout(
        title_text="Confusion Matrices for All Models",
        title_x=0.5,
        title_font={"family": "Styrene B", "size": 24, "color": "#191919"},
        height=height,
        width=width,
        showlegend=False,
        font={**axis_font, "size": 12},
        plot_bgcolor=BACKGROUND_COLOR,
        paper_bgcolor=BACKGROUND_COLOR,
        margin=dict(t=100, b=50, l=50, r=50),
    )

    # Adjust subplot titles
    for i in fig["layout"]["annotations"]:
        i["font"] = dict(size=16, family="Styrene B", color="#191919")
        i["y"] = i["y"] + 0.03

    fig.show()

    if save_path:  # type: ignore
        fig.write_image(save_path)  # type: ignore


def plot_roc_curve(
    y_true: np.ndarray,
    y_pred_proba: np.ndarray,
    save_path: Optional[str] = None,
) -> None:
    """
    Plot and optionally save the Receiver Operating Characteristic (ROC) curve.

    Args:
        y_true: Array of true labels.
        y_pred_proba: Array of predicted probabilities.
        save_path: Optional path to save the plot image.
    """
    fpr, tpr, _ = roc_curve(y_true, y_pred_proba)
    fig = go.Figure()
    fig.add_trace(
        go.Scatter(
            x=fpr,
            y=tpr,
            mode="lines",
            name="ROC curve",
            line=dict(color=PRIMARY_COLORS[0]),
        )
    )
    fig.add_trace(
        go.Scatter(
            x=[0, 1],
            y=[0, 1],
            mode="lines",
            name="Random",
            line=dict(dash="dash", color=PRIMARY_COLORS[1]),
        )
    )
    fig.update_layout(
        title="Receiver Operating Characteristic (ROC) Curve",
        xaxis_title="False Positive Rate",
        yaxis_title="True Positive Rate",
        plot_bgcolor=BACKGROUND_COLOR,
        paper_bgcolor=BACKGROUND_COLOR,
        width=1200,
        height=500,
    )
    fig.show()
    if save_path:
        fig.write_image(save_path)


def plot_precision_recall_curve(
    y_true: np.ndarray,
    y_pred_proba: np.ndarray,
    save_path: Optional[str] = None,
) -> None:
    """
    Plot and optionally save the Precision-Recall curve.

    Args:
        y_true: Array of true labels.
        y_pred_proba: Array of predicted probabilities.
        save_path: Optional path to save the plot image.
    """
    precision, recall, _ = precision_recall_curve(y_true, y_pred_proba)
    fig = go.Figure()
    fig.add_trace(
        go.Scatter(
            x=recall,
            y=precision,
            mode="lines",
            name="PR curve",
            line=dict(color=PRIMARY_COLORS[0]),
        )
    )
    fig.update_layout(
        title="Precision-Recall Curve",
        xaxis_title="Recall",
        yaxis_title="Precision",
        plot_bgcolor=BACKGROUND_COLOR,
        paper_bgcolor=BACKGROUND_COLOR,
        width=1200,
        height=500,
    )
    fig.show()
    if save_path:
        fig.write_image(save_path)


def plot_confusion_matrix(
    y_true: np.ndarray,
    y_pred: np.ndarray,
    labels: Optional[List[str]] = None,
    save_path: Optional[str] = None,
) -> None:
    """Plots and optionally saves the confusion matrix.

    Args:
        y_true (np.ndarray): Array of true labels.
        y_pred (np.ndarray): Array of predicted labels.
        labels (Optional[List[str]], optional): A list of labels for the classes. Defaults to None.
        save_path (Optional[str], optional): The file path to save the plot as an image. Defaults to None.

    Returns:
        None: This function does not return anything. It plots the confusion matrix using Plotly.

    Raises:
        None: This function does not raise any exceptions.
    """
    cm = confusion_matrix(y_true, y_pred)
    cm_percent = cm.astype("float") / cm.sum(axis=1)[:, np.newaxis] * 100

    text = [
        [
            f"TN: {cm[0][0]}<br>({cm_percent[0][0]:.1f}%)",
            f"FP: {cm[0][1]}<br>({cm_percent[0][1]:.1f}%)",
        ],
        [
            f"FN: {cm[1][0]}<br>({cm_percent[1][0]:.1f}%)",
            f"TP: {cm[1][1]}<br>({cm_percent[1][1]:.1f}%)",
        ],
    ]

    colorscale = [
        [0, PRIMARY_COLORS[2]],
        [0.33, PRIMARY_COLORS[1]],
        [0.66, PRIMARY_COLORS[1]],
        [1, PRIMARY_COLORS[0]],
    ]

    fig = go.Figure(
        data=go.Heatmap(
            z=cm,
            x=labels or ["Not Transported", "Transported"],
            y=labels or ["Not Transported", "Transported"],
            hoverongaps=False,
            text=text,
            texttemplate="%{text}",
            colorscale=colorscale,
            showscale=False,
        )
    )

    axis_font = {"family": "Styrene A", "color": "#191919"}

    fig.update_layout(
        title_text="Confusion Matrix",
        title_x=0.5,
        title_font={"family": "Styrene B", "size": 24, "color": "#191919"},
        xaxis_title="Predicted",
        yaxis_title="Actual",
        xaxis=dict(tickfont={**axis_font, "size": 12}),
        yaxis=dict(tickfont={**axis_font, "size": 12}),
        height=500,
        width=1200,
        showlegend=False,
        font={**axis_font, "size": 12},
        plot_bgcolor=BACKGROUND_COLOR,
        paper_bgcolor=BACKGROUND_COLOR,
        margin=dict(t=100, b=50, l=50, r=50),
    )

    fig.show()

    if save_path:
        fig.write_image(save_path)


def plot_learning_curve(
    estimator,
    features: np.ndarray,
    target: np.ndarray,
    cv: int = 5,
    n_jobs: int = -1,
    train_sizes: np.ndarray = np.linspace(0.1, 1.0, 5),
    save_path: Optional[str] = None,
) -> None:
    """
    Plot and optionally save the learning curve for a given estimator.

    Args:
        estimator: The machine learning model to evaluate.
        features: Feature matrix.
        target: Target vector.
        cv: Number of cross-validation folds.
        n_jobs: Number of jobs to run in parallel.
        train_sizes: Array of training set sizes to evaluate.
        save_path: Optional path to save the plot image.
    """
    train_sizes, train_scores, test_scores = learning_curve(
        estimator,
        features,
        target,
        cv=cv,
        n_jobs=n_jobs,
        train_sizes=train_sizes,
    )

    train_scores_mean = np.mean(train_scores, axis=1)
    train_scores_std = np.std(train_scores, axis=1)
    test_scores_mean = np.mean(test_scores, axis=1)
    test_scores_std = np.std(test_scores, axis=1)

    fig = go.Figure()
    fig.add_trace(
        go.Scatter(
            x=train_sizes,
            y=train_scores_mean,
            mode="lines+markers",
            name="Training score",
            line=dict(color=PRIMARY_COLORS[0]),
            error_y=dict(type="data", array=train_scores_std, visible=True),
        )
    )
    fig.add_trace(
        go.Scatter(
            x=train_sizes,
            y=test_scores_mean,
            mode="lines+markers",
            name="Cross-validation score",
            line=dict(color=PRIMARY_COLORS[1]),
            error_y=dict(type="data", array=test_scores_std, visible=True),
        )
    )
    fig.update_layout(
        title="Learning Curve",
        xaxis_title="Training examples",
        yaxis_title="Score",
        plot_bgcolor=BACKGROUND_COLOR,
        paper_bgcolor=BACKGROUND_COLOR,
        width=1200,
        height=500,
    )
    fig.show()
    if save_path:
        fig.write_image(save_path)


=== src/retail_bank_risk/basic_visualizations_utils.py ===
# cspell:disable
# pylint:disable=line-too-long

"""
This module provides a set of functions for creating and displaying various types of plots
to visualize data distributions, feature importances, and correlations using Plotly.

Key functionalities include:
- Plotting histograms, bar charts, and boxplots for specified features.
- Creating correlation matrices for numerical features.
- Visualizing feature importances across different models.
- Comparing data distributions before and after handling missing values.
- Displaying categorical feature distributions by target variables.

Constants:
- `BACKGROUND_COLOR`: The background color used in all plots.
- `PRIMARY_COLORS`: A list of primary colors used for the main elements of the plots.
- `PLOT_COLORS`: A subset of colors used for histogram and bar plot elements.
- `SECONDARY_COLORS`: A set of secondary colors used for additional elements in the plots.
- `ALL_COLORS`: A combination of primary and secondary colors for use across different plots.

Functions:
- `plot_combined_histograms`: Plots histograms for multiple features in a single figure.
- `plot_combined_bar_charts`: Plots bar charts for multiple categorical features.
- `plot_combined_boxplots`: Plots boxplots for multiple numerical features.
- `plot_correlation_matrix`: Plots a correlation matrix for the specified numerical features.
- `plot_feature_importances`: Plots feature importances across different models.
- `plot_distribution_comparison`: Compares feature distributions before and after handling missing values.
- `plot_categorical_features_by_target`: Plots the distribution of categorical features grouped by a target variable.
- `plot_numeric_distributions`: Plots numeric distributions of features grouped by a binary target variable.
- `plot_single_bar_chart`: Plots a percentage bar chart for a single categorical feature.

This module is intended for use in data exploration and analysis workflows, helping to
gain insights into data structure, feature importance, and potential relationships between features.
"""

from typing import List, Optional, Dict

import numpy as np
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots

# Constants
BACKGROUND_COLOR = "#EEECE2"
PRIMARY_COLORS = ["#CC7B5C", "#D4A27F", "#EBDBBC", "#9C8AA5"]
PLOT_COLORS = ["#91A694", "#9C8AA5", "#CC7B5C"]
SECONDARY_COLORS = [
    "#91A694",
    "#8B9BAE",
    "#666663",
    "#BFBFBA",
    "#E5E4DF",
    "#F0F0EB",
    "#FAFAF7",
]
ALL_COLORS = PRIMARY_COLORS + SECONDARY_COLORS


def plot_combined_histograms(
    df: pd.DataFrame,
    features: List[str],
    nbins: int = 40,
    save_path: Optional[str] = None,
) -> None:
    """Plots combined histograms for specified features in the DataFrame.

    Args:
        df: DataFrame containing the features to plot.
        features: List of feature names to plot histograms for.
        nbins: Number of bins for each histogram. Defaults to 40.
        save_path: Optional path to save the plot image.

    Returns:
        None. Displays the plot and optionally saves it to a file.
    """
    title = f"Distribution of {', '.join(features)}"
    rows, cols = 1, len(features)

    fig = make_subplots(rows=rows, cols=cols, horizontal_spacing=0.1)

    axis_font = {"family": "Styrene A", "color": "#191919"}

    for i, feature in enumerate(features):
        fig.add_trace(
            go.Histogram(
                x=df[feature],
                nbinsx=nbins,
                name=feature,
                marker={
                    "color": PRIMARY_COLORS[i % len(PRIMARY_COLORS)],
                    "line": {"color": "#000000", "width": 1},
                },
            ),
            row=1,
            col=i + 1,
        )

        fig.update_xaxes(
            title_text=feature,
            row=1,
            col=i + 1,
            title_standoff=25,
            title_font={**axis_font, "size": 14},
            tickfont={**axis_font, "size": 12},
        )
        fig.update_yaxes(
            title_text="Count",
            row=1,
            col=i + 1,
            title_font={**axis_font, "size": 14},
            tickfont={**axis_font, "size": 12},
        )

    fig.update_layout(
        title_text=title,
        title_x=0.5,
        title_font={"family": "Styrene B", "size": 20, "color": "#191919"},
        showlegend=False,
        template="plotly_white",
        plot_bgcolor=BACKGROUND_COLOR,
        paper_bgcolor=BACKGROUND_COLOR,
        height=500,
        width=400 * len(features),
        margin={"l": 50, "r": 50, "t": 80, "b": 80},
        font={**axis_font, "size": 12},
    )

    fig.show()

    if save_path:
        fig.write_image(save_path)


def plot_combined_bar_charts(
    df: pd.DataFrame,
    features: List[str],
    save_path: Optional[str] = None,
) -> None:
    """Plots combined bar charts for specified categorical features in the DataFrame.

    Args:
        df: DataFrame containing the features to plot.
        features: List of categorical feature names to plot bar charts for.
        save_path: Optional path to save the plot image.

    Returns:
        None. Displays the plot and optionally saves it to a file.
    """
    title = f"Distribution of {', '.join(features)}"
    rows, cols = 1, len(features)

    fig = make_subplots(rows=rows, cols=cols, horizontal_spacing=0.1)

    axis_font = {"family": "Styrene A", "color": "#191919"}

    for i, feature in enumerate(features):
        value_counts = df[feature].value_counts().reset_index()
        value_counts.columns = [feature, "count"]

        fig.add_trace(
            go.Bar(
                x=value_counts[feature],
                y=value_counts["count"],
                name=feature,
                marker={
                    "color": PRIMARY_COLORS[i % len(PRIMARY_COLORS)],
                    "line": {"color": "#000000", "width": 1},
                },
            ),
            row=1,
            col=i + 1,
        )

        fig.update_xaxes(
            title_text=feature,
            row=1,
            col=i + 1,
            title_standoff=25,
            title_font={**axis_font, "size": 14},
            tickfont={**axis_font, "size": 12},
            showticklabels=True,
        )

        fig.update_yaxes(
            title_text="Count",
            row=1,
            col=i + 1,
            title_font={**axis_font, "size": 14},
            tickfont={**axis_font, "size": 12},
        )

    fig.update_layout(
        title_text=title,
        title_x=0.5,
        title_font={"family": "Styrene B", "size": 20, "color": "#191919"},
        showlegend=False,
        template="plotly_white",
        plot_bgcolor=BACKGROUND_COLOR,
        paper_bgcolor=BACKGROUND_COLOR,
        height=500,
        width=400 * len(features),
        margin={"l": 50, "r": 50, "t": 80, "b": 150},
        font={**axis_font, "size": 12},
    )

    fig.show()

    if save_path:
        fig.write_image(save_path)


def plot_combined_boxplots(
    df: pd.DataFrame, features: List[str], save_path: Optional[str] = None
) -> None:
    """Plots combined boxplots for specified numerical features in the DataFrame.

    Args:
        df: DataFrame containing the features to plot.
        features: List of numerical feature names to plot boxplots for.
        save_path: Optional path to save the plot image.

    Returns:
        None. Displays the plot and optionally saves it to a file.
    """
    title = f"Boxplots of {', '.join(features)}"
    rows, cols = 1, len(features)

    fig = make_subplots(rows=rows, cols=cols, horizontal_spacing=0.1)

    axis_font = {"family": "Styrene A", "color": "#191919"}

    for i, feature in enumerate(features):
        fig.add_trace(
            go.Box(
                y=df[feature],
                marker={
                    "color": PRIMARY_COLORS[i % len(PRIMARY_COLORS)],
                    "line": {"color": "#000000", "width": 1},
                },
                boxmean="sd",
                showlegend=False,
            ),
            row=1,
            col=i + 1,
        )
        fig.update_yaxes(
            title_text="Value",
            row=1,
            col=i + 1,
            title_font={**axis_font, "size": 14},
            tickfont={**axis_font, "size": 12},
        )
        fig.update_xaxes(
            tickvals=[0],
            ticktext=[feature],
            row=1,
            col=i + 1,
            title_font={**axis_font, "size": 14},
            tickfont={**axis_font, "size": 12},
            showticklabels=True,
        )

    fig.update_layout(
        title_text=title,
        title_x=0.5,
        title_font={"family": "Styrene B", "size": 20, "color": "#191919"},
        showlegend=False,
        template="plotly_white",
        plot_bgcolor=BACKGROUND_COLOR,
        paper_bgcolor=BACKGROUND_COLOR,
        height=500,
        width=400 * len(features),
        margin={"l": 50, "r": 50, "t": 80, "b": 150},
        font={**axis_font, "size": 12},
    )

    fig.show()

    if save_path:
        fig.write_image(save_path)


def plot_correlation_matrix(
    df: pd.DataFrame, numerical_features: List[str], save_path: str = None
) -> None:
    """Plots the correlation matrix of the specified numerical features in the DataFrame.

    Args:
        df (pd.DataFrame): DataFrame containing the data.
        numerical_features (List[str]): List of numerical features to include in the correlation matrix.
        save_path (str): Path to save the image file (optional).
    """
    numerical_df = df[numerical_features]
    correlation_matrix = numerical_df.corr()

    fig = px.imshow(
        correlation_matrix,
        text_auto=True,
        color_continuous_scale=PRIMARY_COLORS,
        title="Correlation Matrix",
    )

    fig.update_layout(
        title={
            "text": "Correlation Matrix",
            "y": 0.95,
            "x": 0.5,
            "xanchor": "center",
            "yanchor": "top",
        },
        title_font=dict(size=24),
        template="plotly_white",
        height=800,
        width=800,
        margin=dict(l=100, r=100, t=100, b=100),
        xaxis=dict(
            tickangle=-45, title_font=dict(size=18), tickfont=dict(size=14)
        ),
        yaxis=dict(title_font=dict(size=18), tickfont=dict(size=14)),
    )

    fig.show()

    if save_path:
        fig.write_image(save_path)


def plot_feature_importances(
    feature_importances: Dict[str, Dict[str, float]],
    save_path: Optional[str] = None,
) -> None:
    """Plots and optionally saves a bar chart of feature importances across different models.

    Args:
        feature_importances: A dictionary with model names as keys and dicts of feature importances as values.
        save_path: Optional path to save the plot image.

    Returns:
        None. Displays the plot and optionally saves it to a file.
    """
    fig = go.Figure()

    axis_font = {"family": "Styrene A", "color": "#191919"}

    for i, (name, importances) in enumerate(feature_importances.items()):
        fig.add_trace(
            go.Bar(
                x=list(importances.keys()),
                y=list(importances.values()),
                name=name,
                marker_color=PRIMARY_COLORS[i % len(PRIMARY_COLORS)],
                text=[f"{value:.3f}" for value in importances.values()],
                textposition="auto",
            )
        )

    fig.update_layout(
        title={
            "text": "Feature Importances Across Models",
            "y": 0.95,
            "x": 0.5,
            "xanchor": "center",
            "yanchor": "top",
            "font": {"family": "Styrene B", "size": 24, "color": "#191919"},
        },
        xaxis_title="Features",
        yaxis_title="Importance",
        barmode="group",
        template="plotly_white",
        legend_title="Models",
        font={**axis_font, "size": 14},
        height=600,
        width=1200,
        plot_bgcolor=BACKGROUND_COLOR,
        paper_bgcolor=BACKGROUND_COLOR,
    )

    fig.update_xaxes(tickangle=-45, tickfont={**axis_font, "size": 12})
    fig.update_yaxes(
        showgrid=True,
        gridwidth=1,
        gridcolor="LightGrey",
        tickfont={**axis_font, "size": 12},
    )

    fig.show()

    if save_path:
        fig.write_image(save_path)


def plot_distribution_comparison(
    df_before,
    df_after,
    features,
    title="Distribution Comparison",
    save_path=None,
):
    """
    Plots the distribution of specified features before and after handling missing values.

    Args:
        df_before (pd.DataFrame): DataFrame before handling missing values.
        df_after (pd.DataFrame): DataFrame after handling missing values.
        features (list): List of feature names to plot.
        title (str): The title of the plot.

    Returns:
        None. Displays the plot.
    """
    n_features = len(features)
    fig = make_subplots(
        rows=n_features,
        cols=2,
        subplot_titles=[f"{feature} - Before" for feature in features]
        + [f"{feature} - After" for feature in features],
    )

    for i, feature in enumerate(features):
        fig.add_trace(
            go.Histogram(
                x=df_before[feature],
                name="Before",
                marker_color=PRIMARY_COLORS[0],
            ),
            row=i + 1,
            col=1,
        )
        fig.add_trace(
            go.Histogram(
                x=df_after[feature],
                name="After",
                marker_color=PRIMARY_COLORS[1],
            ),
            row=i + 1,
            col=2,
        )

    fig.update_layout(
        title={
            "text": title,
            "y": 0.95,
            "x": 0.5,
            "xanchor": "center",
            "yanchor": "top",
            "font": {"size": 24, "color": "#191919", "family": "Styrene B"},
        },
        showlegend=False,
        template="plotly_white",
        plot_bgcolor=BACKGROUND_COLOR,
        paper_bgcolor=BACKGROUND_COLOR,
        font={"family": "Styrene A", "size": 14, "color": "#191919"},
        height=400 * n_features,
        width=1200,
    )

    fig.show()

    if save_path:
        fig.write_image(save_path)


def plot_categorical_features_by_target(
    df: pd.DataFrame,
    features: List[str],
    target: str,
    save_path: Optional[str] = None,
) -> None:
    """
    Plot the distribution of specified categorical features grouped by a target variable.
    This function creates a grid of bar plots, where each plot represents the distribution
    of a categorical feature, grouped by the target variable. It shows percentages and
    uses a consistent y-axis scale across all subplots.

    Args:
        df (pd.DataFrame): The input DataFrame containing the data to be plotted.
        features (List[str]): A list of column names representing the categorical features to be plotted.
        target (str): The name of the target variable column used for grouping.
        save_path (Optional[str]): The file path to save the plot image. If None, the plot is not saved.

    Returns:
        None. The function displays the plot and optionally saves it to a file.
    """
    num_features = len(features)
    # Determine the number of rows and columns based on the number of features
    if num_features == 1:
        rows, cols = 1, 1
    elif num_features == 2:
        rows, cols = 1, 2
    elif num_features == 3:
        rows, cols = 2, 2
    else:
        rows, cols = (num_features + 1) // 2, 2

    fig = make_subplots(
        rows=rows,
        cols=cols,
        vertical_spacing=0.2,
        horizontal_spacing=0.1,
        # Removed subplot_titles to prevent feature names from appearing at the top
    )

    axis_font = {"family": "Styrene A", "color": "#191919"}
    colors = {0: PRIMARY_COLORS[0], 1: PRIMARY_COLORS[1]}

    for i, feature in enumerate(features):
        row, col = (i // cols) + 1, (i % cols) + 1
        data = (
            df.groupby([feature, target], observed=False)
            .size()
            .unstack(fill_value=0)
        )
        data_percentages = data.div(data.sum(axis=1), axis=0) * 100

        for category in data.columns:
            fig.add_trace(
                go.Bar(
                    x=data.index,
                    y=data_percentages[category],
                    name=f"{target} = {category}",
                    marker_color=colors[category],
                    text=[f"{v:.1f}%" for v in data_percentages[category]],
                    textposition="inside",
                    width=0.35,
                    showlegend=(i == 0),
                ),
                row=row,
                col=col,
            )

        fig.update_xaxes(
            title_text=feature,
            row=row,
            col=col,
            title_standoff=25,
            title_font={**axis_font, "size": 14},
            tickfont={**axis_font, "size": 12},
            showticklabels=True,
        )

        fig.update_yaxes(
            title_text="Percentage" if col == 1 else None,
            row=row,
            col=col,
            title_font={**axis_font, "size": 14},
            tickfont={**axis_font, "size": 12},
            range=[0, 100],
        )

    fig.update_layout(
        title_text=f"Distribution of {', '.join(features)} by {target}",
        title_x=0.5,
        title_font={"family": "Styrene B", "size": 20, "color": "#191919"},
        showlegend=True,
        template="plotly_white",
        plot_bgcolor=BACKGROUND_COLOR,
        paper_bgcolor=BACKGROUND_COLOR,
        height=400 * rows,
        width=600 * cols,
        margin={"l": 50, "r": 150, "t": 100, "b": 50},
        font={**axis_font, "size": 12},
        legend=dict(
            orientation="v",
            yanchor="middle",
            y=0.5,
            xanchor="left",
            x=1.02,
            bgcolor="rgba(255,255,255,0.6)",
            bordercolor="Black",
            borderwidth=1,
            font={**axis_font, "size": 12},
        ),
    )

    fig.show()
    if save_path:
        fig.write_image(save_path)


def plot_numeric_distributions(
    df: pd.DataFrame,
    features: List[str],
    target: str,
    nbins: int = 40,
    save_path: Optional[str] = None,
) -> None:
    """Plots numerical distribution for specified features in the DataFrame.

    Shows distributions for overall (sum of target 0 and 1), target = 0, and target = 1.
    Bars are plotted with overlap, using edge highlighting for distinction.
    Legend is placed on the right side with colors unaffected by opacity.

    Args:
        df: DataFrame containing the features and target variable.
        features: List of feature names to plot distributions for.
        target: Name of the binary target variable column.
        nbins: Number of bins for each histogram. Defaults to 40.
        save_path: Optional path to save the plot image.

    Returns:
        None. Displays the plot and optionally saves it to a file.
    """
    rows, cols = 1, len(features)
    fig = make_subplots(rows=rows, cols=cols, horizontal_spacing=0.05)
    axis_font = {"family": "Styrene A", "color": "#191919"}
    plot_colors = PLOT_COLORS
    categories = ["Overall", "Target = 1", "Target = 0"]

    for i, feature in enumerate(features):
        hist_data = []
        bin_edges = None
        for category in [0, 1]:
            x = df[df[target] == category][feature]
            hist, edges = np.histogram(
                x, bins=nbins, range=(df[feature].min(), df[feature].max())
            )
            hist_data.append(hist)
            if bin_edges is None:
                bin_edges = edges

        overall_hist = hist_data[0] + hist_data[1]
        hist_data = [overall_hist] + hist_data[::-1]

        bin_width = (bin_edges[-1] - bin_edges[0]) / nbins

        for data, color, name in zip(hist_data, plot_colors, categories):
            # Main bar with reduced opacity
            fig.add_trace(
                go.Bar(
                    x=bin_edges[:-1],
                    y=data,
                    name=name,
                    marker_color=color,
                    opacity=0.1,
                    showlegend=False,
                    width=bin_width,
                ),
                row=1,
                col=i + 1,
            )

            # Edge highlight
            fig.add_trace(
                go.Scatter(
                    x=bin_edges[:-1],
                    y=data,
                    mode="lines",
                    line=dict(color=color, width=2),
                    showlegend=(i == 0),
                    name=name,
                    hoverinfo="skip",
                ),
                row=1,
                col=i + 1,
            )

        fig.update_xaxes(
            title_text=feature,
            row=1,
            col=i + 1,
            title_font={**axis_font, "size": 14},
            tickfont={**axis_font, "size": 12},
        )

        if i == 0:
            fig.update_yaxes(
                title_text="Count",
                row=1,
                col=1,
                title_font={**axis_font, "size": 14},
                tickfont={**axis_font, "size": 12},
            )

    fig.update_layout(
        title_text=f"Distribution of {', '.join(features)} by {target}",
        title_x=0.5,
        title_font={"family": "Styrene B", "size": 20, "color": "#191919"},
        showlegend=True,
        legend=dict(
            orientation="v",
            yanchor="middle",  # Changed from "top" to "middle"
            y=0.5,  # Changed from 1 to 0.5 for vertical center
            xanchor="left",
            x=1.02,
            bgcolor="rgba(255,255,255,0.8)",
        ),
        template="plotly_white",
        plot_bgcolor=BACKGROUND_COLOR,
        paper_bgcolor=BACKGROUND_COLOR,
        height=600,
        width=400 * len(features) + 150,
        margin={
            "l": 50,
            "r": 150,
            "t": 80,
            "b": 80,
        },
        font={**axis_font, "size": 12},
        barmode="overlay",
        bargap=0,
        bargroupgap=0,
    )

    fig.show()
    if save_path:
        fig.write_image(save_path)


def plot_single_bar_chart(
    df: pd.DataFrame,
    feature: str,
    save_path: Optional[str] = None,
) -> None:
    """Plots a percentage bar chart for a specified categorical feature in the DataFrame.

    Args:
        df: DataFrame containing the feature to plot.
        feature: Name of the categorical feature to plot.
        save_path: Optional path to save the plot image.

    Returns:
        None. Displays the plot and optionally saves it to a file.
    """
    title = f"Distribution of target variable {feature}"

    value_counts = df[feature].value_counts(normalize=True).reset_index()
    value_counts.columns = [feature, "percentage"]
    value_counts["percentage"] *= 100  # Convert to percentage

    fig = go.Figure()

    for i, (value, percentage) in enumerate(
        zip(value_counts[feature], value_counts["percentage"])
    ):
        fig.add_trace(
            go.Bar(
                x=[value],
                y=[percentage],
                name=f"{feature} = {value}",  # Updated legend label
                marker_color=PRIMARY_COLORS[
                    i % 2
                ],  # Alternate between first two colors
                text=[f"{percentage:.1f}%"],
                textposition="auto",
            )
        )

    axis_font = {"family": "Styrene A", "color": "#191919"}

    fig.update_xaxes(
        title_text=feature,
        title_standoff=25,
        title_font={**axis_font, "size": 14},
        tickfont={**axis_font, "size": 12},
        showticklabels=True,
    )

    fig.update_yaxes(
        title_text="Percentage",
        title_font={**axis_font, "size": 14},
        tickfont={**axis_font, "size": 12},
        range=[0, 100],  # Set y-axis range from 0 to 100
    )

    fig.update_layout(
        title_text=title,
        title_x=0.5,
        title_font={"family": "Styrene B", "size": 20, "color": "#191919"},
        showlegend=True,
        template="plotly_white",
        plot_bgcolor=BACKGROUND_COLOR,
        paper_bgcolor=BACKGROUND_COLOR,
        height=500,
        width=1200,
        margin={"l": 50, "r": 150, "t": 80, "b": 50},
        font={**axis_font, "size": 12},
        barmode="group",
        legend=dict(
            orientation="v",
            yanchor="middle",
            y=0.5,
            xanchor="left",
            x=1.02,
            bgcolor="rgba(255,255,255,0.6)",
            bordercolor="Black",
            borderwidth=1,
            font={**axis_font, "size": 12},
        ),
    )

    fig.show()

    if save_path:
        fig.write_image(save_path)


=== src/retail_bank_risk/data_preprocessing_utils.py ===
# cspell:disable
# pylint:disable=line-too-long
"""
This module provides various functions for data preprocessing, anomaly detection, feature engineering,
and statistical analysis, specifically tailored for machine learning workflows.

Functions included:
- `detect_anomalies_iqr`: Detects anomalies in multiple features using the Interquartile Range (IQR) method.
- `flag_anomalies`: Flags anomalies in specified features using the IQR method.
- `calculate_cramers_v`: Computes Cramer's V statistic for categorical-categorical association.
- `handle_missing_values`: Handles missing data by dropping columns or rows based on a threshold.
- `simple_imputation`: Performs simple imputation on missing values in training and testing datasets.
- `engineer_spaceship_features`: Performs feature engineering, particularly for a spaceship passenger dataset.
- `confidence_interval`: Calculates the confidence interval for a given dataset.
- `create_pipeline`: Creates a scikit-learn pipeline for preprocessing and modeling.

This module is intended for use in data preprocessing and feature engineering, with functions designed to handle common
tasks in machine learning pipelines, such as anomaly detection, missing data handling, and feature engineering.
"""


from collections import Counter
from typing import List, Tuple

import numpy as np
import pandas as pd
import polars as pl
from scipy import stats
from sklearn.pipeline import Pipeline
from sklearn.impute import KNNImputer


def reduce_memory_usage_pl(
    df: pl.DataFrame, verbose: bool = True
) -> pl.DataFrame:
    """Reduces memory usage of a Polars DataFrame by optimizing data types.

    This function attempts to downcast numeric columns to the smallest possible
    data type that can represent the data without loss of information. It also
    converts string columns to categorical type.

    Args:
        df: A Polars DataFrame to optimize.
        verbose: If True, print memory usage before and after optimization.

    Returns:
        A Polars DataFrame with optimized memory usage.

    References:
        Adapted from:
        https://www.kaggle.com/code/demche/polars-memory-usage-optimization
        Original pandas version:
        https://www.kaggle.com/code/arjanso/reducing-dataframe-memory-size-by-65
    """
    if verbose:
        print(f"Size before memory reduction: {df.estimated_size('mb'):.2f} MB")
        print(f"Initial data types: {Counter(df.dtypes)}")

    numeric_int_types = [pl.Int8, pl.Int16, pl.Int32, pl.Int64]
    numeric_float_types = [pl.Float32, pl.Float64]

    for col in df.columns:
        col_type = df[col].dtype

        if col_type in numeric_int_types:
            c_min = df[col].min() * 10  # Prevent possible integer overflow
            c_max = df[col].max() * 10

            if c_min > np.iinfo(np.int8).min and c_max < np.iinfo(np.int8).max:
                new_type = pl.Int8
            elif (
                c_min > np.iinfo(np.int16).min
                and c_max < np.iinfo(np.int16).max
            ):
                new_type = pl.Int16
            elif (
                c_min > np.iinfo(np.int32).min
                and c_max < np.iinfo(np.int32).max
            ):
                new_type = pl.Int32
            else:
                new_type = pl.Int64

            df = df.with_columns(df[col].cast(new_type))

        elif col_type in numeric_float_types:
            c_min, c_max = df[col].min(), df[col].max()
            if (
                c_min > np.finfo(np.float32).min
                and c_max < np.finfo(np.float32).max
            ):
                df = df.with_columns(df[col].cast(pl.Float32))

        elif col_type == pl.String:
            df = df.with_columns(df[col].cast(pl.Categorical))

    if verbose:
        print(f"Size after memory reduction: {df.estimated_size('mb'):.2f} MB")
        print(f"Final data types: {Counter(df.dtypes)}")

    return df


def initial_feature_reduction(
    train_df: pl.DataFrame,
    test_df: pl.DataFrame,
    target_col: str,
    missing_threshold: float = 0.5,
    variance_threshold: float = 0.01,
    correlation_threshold: float = 0.05,
    essential_features: List[str] = None,
) -> Tuple[pl.DataFrame, pl.DataFrame]:
    """Reduces features based on missing values, variance, and correlation.

    This function performs feature reduction on the input DataFrames based on
    missing values, variance, and correlation with the target variable, while
    ensuring that essential features are always retained.

    Args:
        train_df: Training DataFrame.
        test_df: Testing DataFrame.
        target_col: The name of the target variable column.
        missing_threshold: Max allowable missing value ratio. Defaults to 0.5.
        variance_threshold: Min variance required. Defaults to 0.01.
        correlation_threshold: Min absolute correlation with target.
            Defaults to 0.05.
        essential_features: List of features to always keep, regardless of
            reduction criteria. Defaults to None.

    Returns:
        A tuple containing the reduced train and test DataFrames.

    Raises:
        ValueError: If the target column is not in the training DataFrame.
    """
    if target_col not in train_df.columns:
        raise ValueError(
            f"Target column '{target_col}' not found in training data."
        )

    essential_features = essential_features or []

    combined_df = pl.concat([train_df.drop(target_col), test_df])
    total_rows = len(combined_df)

    cols_to_keep_missing = _filter_by_missing_values(
        combined_df.drop(essential_features), total_rows, missing_threshold
    )
    filtered_df = combined_df.select(cols_to_keep_missing + essential_features)

    numeric_cols = _get_numeric_columns(filtered_df)
    numeric_cols = [
        col for col in numeric_cols if col not in essential_features
    ]

    cols_to_keep_variance = _filter_by_variance(
        filtered_df, numeric_cols, variance_threshold
    )

    cols_to_keep_correlation = _filter_by_correlation(
        train_df, numeric_cols, target_col, correlation_threshold
    )

    final_cols = list(
        set(cols_to_keep_missing)
        & set(cols_to_keep_variance)
        & set(cols_to_keep_correlation)
    )
    final_cols.extend(
        [col for col in cols_to_keep_missing if col not in numeric_cols]
    )
    final_cols.extend(essential_features)

    return (
        train_df.select([target_col] + final_cols),
        test_df.select(final_cols),
    )


def impute_numerical_features(train_df, test_df, target_col):
    """Imputes missing values in numerical features using KNNImputer.

    Args:
        train_df: Polars DataFrame for the training set.
        test_df: Polars DataFrame for the test set.
        target_col: Name of the target column in the training set.

    Returns:
        Tuple of imputed training and test DataFrames.
    """
    if not train_df.shape[0] or not test_df.shape[0]:
        print(
            "Warning: One of the DataFrames is empty. Skipping numerical imputation."
        )
        return train_df, test_df

    numerical_features = [
        col
        for col, dtype in zip(train_df.columns, train_df.dtypes)
        if dtype
        in (pl.Int8, pl.Int16, pl.Int32, pl.Int64, pl.Float32, pl.Float64)
        and col != target_col
    ]

    if not numerical_features:
        print(
            "Warning: No numerical features found. Skipping numerical imputation."
        )
        return train_df, test_df

    imputer = KNNImputer(n_neighbors=5)

    train_target = train_df[target_col]
    train_features = train_df.drop(target_col)

    train_numerical_pd = train_features[numerical_features].to_pandas()
    test_numerical_pd = test_df[numerical_features].to_pandas()

    train_numerical_imputed = imputer.fit_transform(train_numerical_pd)
    test_numerical_imputed = imputer.transform(test_numerical_pd)

    train_numerical_imputed_df = pl.DataFrame(
        train_numerical_imputed, schema=numerical_features
    )
    test_numerical_imputed_df = pl.DataFrame(
        test_numerical_imputed, schema=numerical_features
    )

    train_df = (
        train_features.drop(numerical_features)
        .hstack(train_numerical_imputed_df)
        .with_columns(train_target)
    )

    test_df = test_df.drop(numerical_features).hstack(test_numerical_imputed_df)

    return train_df, test_df


def impute_categorical_features(train_df, test_df, target_col):
    """Imputes missing values in categorical features using the mode.

    Args:
        train_df: Polars DataFrame for the training set.
        test_df: Polars DataFrame for the test set.
        target_col: Name of the target column in the training set.

    Returns:
        Tuple of imputed training and test DataFrames.
    """
    if not train_df.shape[0] or not test_df.shape[0]:
        print(
            "Warning: One of the DataFrames is empty. Skipping categorical imputation."
        )
        return train_df, test_df

    categorical_features = [
        col
        for col, dtype in zip(train_df.columns, train_df.dtypes)
        if dtype == pl.Categorical and col != target_col
    ]

    if not categorical_features:
        print("Warning: No categorical features found. Skipping imputation.")
        return train_df, test_df

    for col in categorical_features:
        train_df = train_df.with_columns(pl.col(col).fill_null("mode"))
        test_df = test_df.with_columns(pl.col(col).fill_null("mode"))

    return train_df, test_df


def count_duplicated_rows(dataframe: pl.DataFrame) -> None:
    """
    Count and print the number of duplicated rows in a Polars DataFrame
    (based on all columns).
    """
    num_duplicated_rows = dataframe.is_duplicated().sum()
    print(f"The DataFrame contains {num_duplicated_rows} duplicated rows.")


def _filter_by_missing_values(
    df: pl.DataFrame, total_rows: int, threshold: float
) -> List[str]:
    """Filters columns based on missing value ratio.

    Args:
        df: DataFrame to filter.
        total_rows: Total number of rows in the DataFrame.
        threshold: Maximum allowed ratio of missing values.

    Returns:
        List of column names that pass the missing value filter.
    """
    missing_ratios = df.null_count() / total_rows
    return [
        col
        for col, ratio in zip(df.columns, missing_ratios.to_numpy()[0])
        if ratio <= threshold
    ]


def _get_numeric_columns(df: pl.DataFrame) -> List[str]:
    """Returns a list of numeric column names.

    Args:
        df: DataFrame to analyze.

    Returns:
        List of column names with numeric data types.
    """
    numeric_types = (
        pl.Float32,
        pl.Float64,
        pl.Int8,
        pl.Int16,
        pl.Int32,
        pl.Int64,
    )
    return [col for col in df.columns if df[col].dtype in numeric_types]


def _filter_by_variance(
    df: pl.DataFrame, columns: List[str], threshold: float
) -> List[str]:
    """Filters columns based on variance.

    Args:
        df: DataFrame containing the columns to filter.
        columns: List of column names to consider.
        threshold: Minimum required variance.

    Returns:
        List of column names that pass the variance filter.
    """
    variances = df.select(columns).var().to_dict(as_series=False)
    return [col for col, var in variances.items() if var[0] > threshold]


def _filter_by_correlation(
    df: pl.DataFrame, columns: List[str], target_col: str, threshold: float
) -> List[str]:
    """Filters columns based on correlation with the target variable.

    Args:
        df: DataFrame containing the columns and target variable.
        columns: List of column names to consider.
        target_col: Name of the target column.
        threshold: Minimum required absolute correlation.

    Returns:
        List of column names that pass the correlation filter.
    """

    def correlation_with_target(col: str) -> float:
        """Calculates absolute Pearson correlation with the target."""
        x = df[col].to_numpy()
        y = df[target_col].to_numpy()
        mask = ~np.isnan(x) & ~np.isnan(y)
        return np.abs(np.corrcoef(x[mask], y[mask])[0, 1])

    correlations = {col: correlation_with_target(col) for col in columns}
    return ["amt_income_total"] + [
        col
        for col, corr in correlations.items()
        if corr > threshold and col != "amt_income_total"
    ]


def detect_anomalies_iqr(df: pd.DataFrame, features: List[str]) -> pd.DataFrame:
    """Detects anomalies in multiple features using the IQR method.

    Args:
        df (pd.DataFrame): DataFrame containing the data.
        features (List[str]): List of features to detect anomalies in.

    Returns:
        pd.DataFrame: DataFrame containing the anomalies for each feature.
    """
    anomalies_list = []

    for feature in features:
        if feature not in df.columns:
            print(f"Feature '{feature}' not found in DataFrame.")
            continue

        if not np.issubdtype(df[feature].dtype, np.number):
            print(f"Feature '{feature}' is not numerical and will be skipped.")
            continue

        q1 = df[feature].quantile(0.25)
        q3 = df[feature].quantile(0.75)
        iqr = q3 - q1
        lower_bound = q1 - 1.5 * iqr
        upper_bound = q3 + 1.5 * iqr
        feature_anomalies = df[
            (df[feature] < lower_bound) | (df[feature] > upper_bound)
        ]
        if not feature_anomalies.empty:
            print(f"Anomalies detected in feature '{feature}':")
            print(feature_anomalies)
        else:
            print(f"No anomalies detected in feature '{feature}'.")
        anomalies_list.append(feature_anomalies)

    if anomalies_list:
        anomalies = (
            pd.concat(anomalies_list).drop_duplicates().reset_index(drop=True)
        )
        anomalies = anomalies[features]
    else:
        anomalies = pd.DataFrame(columns=features)

    return anomalies


def flag_anomalies(df: pd.DataFrame, features: List[str]) -> pd.Series:
    """
    Identify and flag anomalies in a DataFrame based on the Interquartile Range (IQR) method for specified features.

    Args:
        df (pd.DataFrame): The input DataFrame containing the data.
        features (List[str]): A list of column names in the DataFrame to check for anomalies.

    Returns:
        pd.Series: A Series of boolean values where True indicates an anomaly in any of the specified features.
    """
    anomaly_flags = pd.Series(False, index=df.index)

    for feature in features:
        first_quartile = df[feature].quantile(0.25)
        third_quartile = df[feature].quantile(0.75)
        interquartile_range = third_quartile - first_quartile
        lower_bound = first_quartile - 1.5 * interquartile_range
        upper_bound = third_quartile + 1.5 * interquartile_range

        feature_anomalies = (df[feature] < lower_bound) | (
            df[feature] > upper_bound
        )
        anomaly_flags |= feature_anomalies

    return anomaly_flags


def calculate_cramers_v(x, y):
    """
    Calculates Cramer's V statistic for categorical-categorical association.

    Args:
        x: pandas Series
        y: pandas Series

    Returns:
        float: Cramer's V
    """
    confusion_matrix = pd.crosstab(x, y)
    chi2 = stats.chi2_contingency(confusion_matrix)[0]
    n = confusion_matrix.sum().sum()
    min_dim = min(confusion_matrix.shape) - 1
    return np.sqrt(chi2 / (n * min_dim))


def get_top_missing_value_percentages(
    df: pl.DataFrame, top_n: int = 5
) -> pl.DataFrame:
    """Calculates the percentage of missing values for each column in a Polars DataFrame
    and returns the top N columns with the highest percentage of missing values.

    Args:
        df: The Polars DataFrame to analyze for missing values.
        top_n: The number of top columns to return (default is 5).

    Returns:
        pl.DataFrame: A Polars DataFrame with columns for column names and missing
        value percentages.
    """
    total_rows = df.height
    missing_counts = df.null_count().row(0)
    missing_percentages = [
        {"column": col, "missing_percentage": count / total_rows * 100}
        for col, count in zip(df.columns, missing_counts)
        if count > 0
    ]

    if missing_percentages:
        missing_df = pl.DataFrame(missing_percentages)
        return (
            missing_df.sort("missing_percentage", descending=True)
            .with_columns(pl.col("missing_percentage").round(2))
            .head(top_n)
        )
    else:
        return pl.DataFrame()


def analyze_missing_values(
    train_df: pl.DataFrame, test_df: pl.DataFrame, top_n: int = 5
) -> None:
    """Analyzes and prints the top N columns with the highest percentage of missing values
    for both train and test DataFrames.

    Args:
        train_df: The training Polars DataFrame.
        test_df: The testing Polars DataFrame.
        top_n: The number of top columns to display (default is 5).
    """
    train_missing = get_top_missing_value_percentages(train_df, top_n)
    test_missing = get_top_missing_value_percentages(test_df, top_n)

    if train_missing.is_empty():
        print("No missing values found in the reduced train set.")
    else:
        print(f"Top {top_n} columns with missing values in reduced train set:")
        print(train_missing)

    if test_missing.is_empty():
        print("No missing values found in the reduced test set.")
    else:
        print(f"\nTop {top_n} columns with missing values in reduced test set:")
        print(test_missing)


def confidence_interval(
    data: List[float], confidence: float = 0.95
) -> Tuple[float, float, float]:
    """Calculates the confidence interval for a given dataset.

    Args:
        data (List[float]): A list of numerical data points.
        confidence (float): The confidence level for the interval. Defaults to 0.95.

    Returns:
        Tuple[float, float, float]: A tuple containing the mean, lower bound, and upper bound of the confidence interval.
    """
    array_data = np.array(data, dtype=float)
    sample_size = len(array_data)
    mean_value = np.mean(array_data)
    standard_error = stats.sem(array_data)
    margin_of_error = standard_error * stats.t.ppf(
        (1 + confidence) / 2.0, sample_size - 1
    )
    return (
        mean_value,
        mean_value - margin_of_error,
        mean_value + margin_of_error,
    )


def create_pipeline(preprocessor: Pipeline, model: Pipeline) -> Pipeline:
    """
    Create a machine learning pipeline with a preprocessor and a classifier.

    Parameters:
    preprocessor (sklearn.base.TransformerMixin): The preprocessing component of the pipeline.
    model (sklearn.base.BaseEstimator): The classifier component of the pipeline.

    Returns:
    sklearn.pipeline.Pipeline: A scikit-learn Pipeline object that sequentially applies the preprocessor and the classifier.
    """
    return Pipeline([("preprocessor", preprocessor), ("classifier", model)])


=== src/retail_bank_risk/model_utils.py ===
# cspell:disable
# pylint:disable=line-too-long

"""
This module provides functions for evaluating machine learning models and extracting feature importances.

Functions included:
- `evaluate_model`: Evaluates the performance of a trained model using various metrics, including optional threshold adjustment.
- `extract_feature_importances`: Extracts feature importances using permutation importance for models that do not provide them directly.

Key Features:
- Evaluation metrics include ROC AUC, PR AUC, F1 Score, Precision, Recall, and Balanced Accuracy.
- The `evaluate_model` function allows for adjusting the decision threshold based on a target recall.
- The `extract_feature_importances` function uses permutation importance for models that lack direct feature importance attributes.

This module is intended for use in machine learning workflows to assess model performance and interpret feature importance.
"""

from typing import Dict, Union

import numpy as np
import pandas as pd
from sklearn.inspection import permutation_importance
from sklearn.metrics import (
    average_precision_score,
    balanced_accuracy_score,
    classification_report,
    confusion_matrix,
    f1_score,
    precision_recall_curve,
    precision_score,
    recall_score,
    roc_auc_score,
)


def evaluate_model(
    model,
    features: np.ndarray,
    true_labels: np.ndarray,
    dataset_name: str = None,
    threshold: float = None,
    target_recall: float = None,
) -> Dict[str, Union[float, np.ndarray]]:
    """
    Evaluate a model's performance with optional threshold adjustment.

    Args:
        model: The trained model to evaluate.
        features (np.ndarray): Feature data.
        true_labels (np.ndarray): True labels.
        dataset_name (str, optional): Name of the dataset for display purposes.
        threshold (float, optional): Custom threshold for classification.
        target_recall (float, optional): Target recall for threshold adjustment.

    Returns:
        Dict[str, Union[float, np.ndarray]]: Dictionary containing various performance metrics.
    """
    y_pred_proba = model.predict_proba(features)[:, 1]

    if target_recall is not None:
        _, recalls, thresholds = precision_recall_curve(
            true_labels, y_pred_proba
        )
        idx = np.argmin(np.abs(recalls - target_recall))
        threshold = thresholds[idx]
        print(f"Adjusted threshold: {threshold:.4f}")

    # Use the threshold if provided or adjusted, otherwise use default 0.5
    if threshold is not None:
        y_pred = (y_pred_proba >= threshold).astype(int)
    else:
        y_pred = model.predict(features)

    if dataset_name:
        print(f"\nResults on {dataset_name} set:")

    print(
        classification_report(true_labels, y_pred, zero_division=1)
    )  # Modified line
    print("Confusion Matrix:")
    print(confusion_matrix(true_labels, y_pred))
    print(f"ROC AUC: {roc_auc_score(true_labels, y_pred_proba):.4f}")
    print(f"PR AUC: {average_precision_score(true_labels, y_pred_proba):.4f}")
    print(f"F1 Score: {f1_score(true_labels, y_pred, zero_division=1):.4f}")
    print(
        f"Precision: {precision_score(true_labels, y_pred, zero_division=1):.4f}"
    )
    print(f"Recall: {recall_score(true_labels, y_pred):.4f}")
    print(
        f"Balanced Accuracy: {balanced_accuracy_score(true_labels, y_pred):.4f}"
    )

    return {
        "roc_auc": roc_auc_score(true_labels, y_pred_proba),
        "pr_auc": average_precision_score(true_labels, y_pred_proba),
        "f1": f1_score(true_labels, y_pred, zero_division=1),
        "precision": precision_score(true_labels, y_pred, zero_division=1),
        "recall": recall_score(true_labels, y_pred),
        "balanced_accuracy": balanced_accuracy_score(true_labels, y_pred),
        "threshold": threshold if threshold is not None else 0.5,
        "y_pred": y_pred,
        "y_pred_proba": y_pred_proba,
    }


def extract_feature_importances(
    model, feature_data: pd.DataFrame, target_data: Union[pd.Series, np.ndarray]
) -> np.ndarray:
    """
    Extract feature importances using permutation importance for models that do not directly provide them.

    Args:
        model: Trained model.
        feature_data (pd.DataFrame): Feature data.
        target_data (Union[pd.Series, np.ndarray]): Target data.

    Returns:
        np.ndarray: Array of feature importances.
    """
    if hasattr(model, "feature_importances_"):
        return model.feature_importances_
    else:
        # Calculate permutation importance
        permutation_import = permutation_importance(
            model, feature_data, target_data, n_repeats=30, random_state=42
        )
        return permutation_import.importances_mean




